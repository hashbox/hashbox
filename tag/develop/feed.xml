<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>https://hashbox.github.io/</title>
   
   <link>https://hashbox.github.io/</link>
   <description>빅데이터 분야에 모험가가 되고 싶은 개발자 블로그</description>
   <language>ko-kr</language>
   
   <title>
   <![CDATA[ HASHBOX ]]>
   </title>
   <description>
   <![CDATA[ 빅데이터 분야에 모험가가 되고 싶은 개발자 블로그 ]]>
   </description>
   <link>https://hashbox.github.io/</link>
   <image>
   <url>https://hashbox.github.io/assets/images/favicon.ico</url>
   <title>HASHBOX</title>
   <link>https://hashbox.github.io/</link>
   </image>
   <generator>Jekyll 3.6.2</generator>
   <lastBuildDate></lastBuildDate>
   <atom:link href="https://hashbox.github.io/rss.xml" rel="self" type="application/rss+xml"/>
   <ttl>60</ttl>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>맥에서 Python Matplotlib Import문제 해결 방법</title>
	  <link>https://hashbox.github.io/Matplotlib-Mac-%EC%82%AC%EC%9A%A9</link>
		
				
		
				
						<author>한지승(Jee Seung, Han)</author>
				
		
	  <pubDate>2018-01-15T14:22:00+00:00</pubDate>
	  <guid>https://hashbox.github.io/Matplotlib-Mac-%EC%82%AC%EC%9A%A9</guid>
	  <description><![CDATA[
	     <blockquote>
  <p>필자는 맥에서 virtualenv를 통해 Python을 사용하고 있습니다. 데이터 관련 그래프를 사용하기 위해 <code class="highlighter-rouge">matplotlib</code>을 설치하고 <code class="highlighter-rouge">import</code>를 하는 구문에서 다음과 같은 에러가 나타났습니다.</p>
</blockquote>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RuntimeError: Python is not installed as a framework. The Mac OS X backend will not be able to <span class="k">function </span>correctly <span class="k">if </span>Python is not installed as a framework. See the Python documentation <span class="k">for </span>more information on installing Python as a framework on Mac OS X. Please either reinstall Python as a framework, or try one of the other backends. If you are using <span class="o">(</span>Ana<span class="o">)</span>Conda please install python.app and replace the use of <span class="s1">'python'</span> with <span class="s1">'pythonw'</span><span class="nb">.</span> See <span class="s1">'Working with Matplotlib on OSX'</span> <span class="k">in </span>the Matplotlib FAQ <span class="k">for </span>more information.
</code></pre></div></div>

<p>맥에서는 <code class="highlighter-rouge">matplotlib</code>를 사용하는데 있어서 추가적인 조치가 필요하다는 것을 찾았고 해결방법을 찾았습니다.</p>

<h2 id="해결방법1-스크립트-내-명기">해결방법#1 스크립트 내 명기</h2>

<p>Python 스크립트 내에서 사용할 때마다 매번 추가해주는 방법으로 해결이 가능합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">matplotlib</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s">'TkAgg'</span><span class="p">)</span>
</code></pre></div></div>

<p>위와 같이 <code class="highlighter-rouge">matplotlib</code>의 backend를 <code class="highlighter-rouge">TkAgg</code>로 설정을 하면 오류를 해결할 수 있습니다.</p>

<h2 id="해결방법2-설정파일-명기">해결방법#2 설정파일 명기</h2>

<p>저와 같은 경우에는 이 방법을 사용하고 있습니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="s2">"backend: TkAgg"</span> <span class="o">&gt;&gt;</span> ~/.matplotlib/matplotlibrc
</code></pre></div></div>
<p>이 방법은 한번 설정만 하면 매 스크립트마다 추가를 해줄 필요가 없기 때문에 가장 편한 방법으로 생각됩니다.</p>

<hr />

<p>독자분들도 같은 오류를 뿜어낸다면 위와 같은 방법으로 모두 해결되리라 생각됩니다. 감사합니다.</p>

	  ]]></description>
	</item>

	<item>
	  <title>PyTorch 기본 사용법[2/2]</title>
	  <link>https://hashbox.github.io/PyTorch-%EA%B8%B0%EB%B3%B8%EC%82%AC%EC%9A%A9%EB%B2%95-2-2</link>
		
				
		
				
						<author>한지승(Jee Seung, Han)</author>
				
		
	  <pubDate>2018-01-14T11:21:00+00:00</pubDate>
	  <guid>https://hashbox.github.io/PyTorch-%EA%B8%B0%EB%B3%B8%EC%82%AC%EC%9A%A9%EB%B2%95-2-2</guid>
	  <description><![CDATA[
	     <h1 id="개요">개요</h1>

<p>기본적으로 PyTorch를 사용하면서 자주 쓰게 되는 메소드에 대해서 설명하고자 합니다. 기본적으로 PyTorch 도큐먼트 내용이 잘 나와있습니다. 해당 도큐먼트를 기반으로 쉽게 설명을 위해 포스팅합니다. 현재 PyTorch 0.3.0 도큐먼트 기반으로 작성합니다.</p>

<p><strong>기본사용법 시리즈</strong></p>

<ol>
  <li><a href="/PyTorch-기본사용법-1-2">PyTorch 기본사용법 [1/2]</a></li>
  <li>PyTorch 기본사용법 [2/2] (현재글)</li>
</ol>

<hr />

<h2 id="텐서-조작">텐서 조작</h2>

<h3 id="torch">Torch[:,:]</h3>

<p>텐서는 Python을 기존에 사용하시던 분들은 쉽게 이해하실 수 있으실 겁니다. 배열 인덱싱을 매트릭스로 한다고 생각하시면 될 것 같습니다. 매트릭스에서 각 요소의 위치를 ij로 나타내면서 00, 01, 10, 11과 같이 나타낸 것을 Python 인덱싱을 하듯이 하면 됩니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="s">'''
 0.3348  0.0717  0.8247
 0.5290  0.6360  0.4265
 0.4244  0.2309  0.9879
 0.9493  0.7278  0.0516
[torch.FloatTensor of size 4x3]
'''</span>
<span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span>
<span class="s">'''
 0.3348
 0.0717
 0.8247
[torch.FloatTensor of size 3]
'''</span>
<span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
<span class="s">'''
 0.3348  0.0717
 0.5290  0.6360
[torch.FloatTensor of size 2x2]
'''</span>
</code></pre></div></div>

<p>매트릭스를 표현할 때 아무것도 아닌 빈공간을 두는 것 대신에 <code class="highlighter-rouge">:</code>을 사용하고, <code class="highlighter-rouge">,</code>로 차원을 구분하여 사용한다고 생각하면 됩니다.</p>

<h3 id="torchcat">torch.cat()</h3>

<p><code class="highlighter-rouge">torch.cat()</code>은 두개의 텐서를 이어 붙이는 메소드입니다. 그러기 위해서는 이어 붙이고자하는 차원에 따라 차원의 사이즈를 맞춰주시는 것도 잊지 마셔야합니다!</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="s">'''
 0.1457  0.1454  0.9445
 0.8396  0.5484  0.9036
[torch.FloatTensor of size 2x3]
'''</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="s">'''
 0.3265  0.8622  0.5800
 0.3340  0.7720  0.9725
[torch.FloatTensor of size 2x3]
'''</span>

<span class="n">result1</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="s">'''
 0.1457  0.1454  0.9445
 0.8396  0.5484  0.9036
 0.3265  0.8622  0.5800
 0.3340  0.7720  0.9725
[torch.FloatTensor of size 4x3]
'''</span>
<span class="n">result2</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="s">'''
 0.1457  0.1454  0.9445  0.3265  0.8622  0.5800
 0.8396  0.5484  0.9036  0.3340  0.7720  0.9725
[torch.FloatTensor of size 2x6]
'''</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">dim=0</code>을 주면 0번째 차원은 밑으로 붙습니다. 1번쨰 차원은 오른쪽으로 붙으며 2번째 차원이면 새로이 쌓이듯 이어 붙여지겠죠?</p>

<h3 id="torchchunk-torchsplit">torch.chunk(), torch.split()</h3>

<p><code class="highlighter-rouge">torch.chunk()</code>는 하나의 텐서를 여러개로 나누는 메소드입니다. 첫번 째 인자로 나누고자 하는 <code class="highlighter-rouge">Tensor</code>가 들어가며 2번째 인자로 몇개로 나눌것인지, <code class="highlighter-rouge">dim=n</code>와 같이 <code class="highlighter-rouge">dim</code>에 어떤 차원으로 나눌것인지 명명을 해주면 됩니다. <code class="highlighter-rouge">torch.split()</code>도 같은 역할을 하지만 정확한 사이즈로 나누어주는 역할을 합니다. 마치 <code class="highlighter-rouge">n</code>으로 나누고 남은것을 반환해준다 생각해주시면 됩니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="s">'''
 0.4231  0.0197  0.2480  0.6880  0.1073
 0.7987  0.4116  0.7590  0.4709  0.1713
 0.7875  0.3960  0.6544  0.0566  0.9989
 0.7098  0.0270  0.2983  0.2765  0.4520
 0.8770  0.8683  0.8228  0.3313  0.2859
 0.9922  0.2215  0.6708  0.5745  0.7009
[torch.FloatTensor of size 6x5]
'''</span>
<span class="n">result1</span><span class="p">,</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">chunk</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="s">'''
(
  0.4231  0.0197  0.2480  0.6880  0.1073
  0.7987  0.4116  0.7590  0.4709  0.1713
  0.7875  0.3960  0.6544  0.0566  0.9989
 [torch.FloatTensor of size 3x5],
  0.7098  0.0270  0.2983  0.2765  0.4520
  0.8770  0.8683  0.8228  0.3313  0.2859
  0.9922  0.2215  0.6708  0.5745  0.7009
 [torch.FloatTensor of size 3x5])
'''</span>
<span class="n">result3</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="s">'''
(
  0.4231  0.0197
  0.7987  0.4116
  0.7875  0.3960
  0.7098  0.0270
  0.8770  0.8683
  0.9922  0.2215
 [torch.FloatTensor of size 6x2],
  0.2480  0.6880
  0.7590  0.4709
  0.6544  0.0566
  0.2983  0.2765
  0.8228  0.3313
  0.6708  0.5745
 [torch.FloatTensor of size 6x2],
  0.1073
  0.1713
  0.9989
  0.4520
  0.2859
  0.7009
 [torch.FloatTensor of size 6x1])
'''</span>
</code></pre></div></div>

<h3 id="torchsqueeze-torchunsqueeze">torch.squeeze(), torch.unsqueeze()</h3>

<p><code class="highlighter-rouge">torch.squeeze()</code>와 <code class="highlighter-rouge">torch.unsqueeze()</code>는 서로 상반된 역할을 합니다. ‘쥐어짜다’라는 느낌에서 어떤 역할을 할지 감이 오지 않으신가요? 맞습니다. <code class="highlighter-rouge">torch.squeeze()</code>를 할경우 차원의 사이즈가 ‘1’인 차원을 없애주며, 반대로 <code class="highlighter-rouge">torch.unsqueeze()</code>는 차원의 사이즈가 ‘1’인 차원을 원하는 차원에 생성을 해줍니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="s">'''
torch.Size([4, 1, 2, 1, 3])
'''</span>

<span class="n">squeeze_x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="s">'''
torch.Size([4, 2, 3])
'''</span>

<span class="n">unsqueeze_x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="n">squeeze_x</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="s">'''
torch.Size([4, 1, 2, 3])
'''</span>
</code></pre></div></div>

<hr />
<h1 id="마치며">마치며</h1>

<p>이번 포스트에서도 기본적으로 PyTorch에서 자주 쓰는 메소드들에 대해서 알아 보았습니다. 처음 PyTorch를 사용하는데 있어서 가장 많이 쓰이고 필요한 메소드들에 대해서 알아보았습니다. 조금이나마 모두에게 도움이 되었으면 좋겠습니다. 감사합니다.</p>

	  ]]></description>
	</item>

	<item>
	  <title>PyTorch 기본 사용법[1/2]</title>
	  <link>https://hashbox.github.io/PyTorch-%EA%B8%B0%EB%B3%B8%EC%82%AC%EC%9A%A9%EB%B2%95-1-2</link>
		
				
		
				
						<author>한지승(Jee Seung, Han)</author>
				
		
	  <pubDate>2018-01-11T10:45:00+00:00</pubDate>
	  <guid>https://hashbox.github.io/PyTorch-%EA%B8%B0%EB%B3%B8%EC%82%AC%EC%9A%A9%EB%B2%95-1-2</guid>
	  <description><![CDATA[
	     <h1 id="개요">개요</h1>

<p>기본적으로 PyTorch를 사용하면서 자주 쓰게 되는 메소드에 대해서 설명하고자 합니다. 기본적으로 PyTorch 도큐먼트 내용이 잘 나와있습니다. 해당 도큐먼트를 기반으로 쉽게 설명을 위해 포스팅합니다. 현재 PyTorch 0.3.0 도큐먼트 기반으로 작성합니다.</p>

<p><strong>기본사용법 시리즈</strong></p>

<ol>
  <li>PyTorch 기본사용법 [1/2] (현재글)</li>
  <li><a href="/PyTorch-기본사용법-2-2">PyTorch 기본사용법 [2/2]</a></li>
</ol>

<hr />

<h2 id="텐서-생성">텐서 생성</h2>

<h3 id="torchtensor">torch.Tensor()</h3>

<p><code class="highlighter-rouge">torch.Tensor()</code>는 여러 매개변수로 오버로딩이 되어있습니다. 사이즈를 넘길 경우 해당하는 사이즈의 Tensor를 생성해주며 배열을 넣을 경우 해당하는 배열의 수를 갖는 Tensor를 생성합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="s">'''
1.00000e-29 *
  0.0000 -2.5244  0.0000
 -2.5244  0.0000  0.0000
[torch.FloatTensor of size 2x3]
'''</span>

<span class="n">y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="s">'''
 1  2
 3  4
[torch.FloatTensor of size 2x2]
'''</span>
</code></pre></div></div>

<h3 id="torchrandsize">torch.rand(size)</h3>

<p><code class="highlighter-rouge">torch.rand()</code>는 텐서를 랜덤하게 생성하는 메소드이며, 0이상 1미만의 수로 사이즈 만큼 생성합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="s">'''
0.4218  0.2046  0.8776
0.1623  0.6642  0.5808
[torch.FloatTensor of size 2x3]
'''</span>
</code></pre></div></div>

<p>매개변수로 넘긴는 차원 수 만큼 FloatTensor로 균등분포(uniform distribution)로 랜덤하게 생성되는 메소드입니다.</p>

<h3 id="torchrandnsize">torch.randn(size)</h3>

<p><code class="highlighter-rouge"> torch.randn()</code>도 텐서를 랜덤하게 생성하는 메소드이며 0를 평균으로 갖는 수로 사이즈 만큼 생성합니다. 여기서 다른 점은 <code class="highlighter-rouge">torch.rand()</code>와는 다르게 정규분포(normal distribution)으로 Tensor를 생성합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="s">'''
-0.9745 -1.7317  0.1979
-1.7215 -1.0405  0.2917
[torch.FloatTensor of size 2x3]
'''</span>
</code></pre></div></div>

<p>Uniform distribution과 Normal distribution의 차이를 알 수 있는 이미지를 보시면 쉽게 이해하실 수 있으실겁니다.</p>

<p><img src="assets/images/distribution-graph.jpg" alt="Distribution 비교 그래프" /></p>

<blockquote>
  <p>이미지 출처 : <a href="https://www.quora.com/What-is-the-difference-between-normal-distribution-and-uniform-distribution">quora.com</a></p>
</blockquote>

<h3 id="torchrandpermn">torch.randperm(n)</h3>

<p><code class="highlighter-rouge">torch.randperm()</code>은 0부터 n-1만큼 배열을 무작위로 섞은 Tensor를 생성합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randperm</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="s">'''
 3
 0
 4
 2
 1
[torch.LongTensor of size 5]
'''</span>
</code></pre></div></div>

<h3 id="torchzerossize">torch.zeros(size)</h3>

<p><code class="highlighter-rouge">torch.zeros()</code>는 <code class="highlighter-rouge">size</code>만큼의 차원을 가진 Tensor를 0으로 채워서 생성해주는 메소드입니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="s">'''
 0  0  0
 0  0  0
[torch.FloatTensor of size 2x3]
'''</span>
</code></pre></div></div>

<h3 id="torchonessize">torch.ones(size)</h3>

<p><code class="highlighter-rouge">torch.ones()</code>는 그럼 무엇일까요? 당연히 <code class="highlighter-rouge">size</code>만큼의 차원을 가진 Tensor를 1로 채워서 생성해주는 메소드입니다. 쉽죠?</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="s">'''
 1  1  1
 1  1  1
[torch.FloatTensor of size 2x3]
'''</span>
</code></pre></div></div>

<h3 id="torcharangestart-end-step">torch.arange(start, end, step)</h3>

<p><code class="highlighter-rouge">torch.arange()</code>는 <code class="highlighter-rouge">start</code>이상 <code class="highlighter-rouge">end</code>미만의 수로 <code class="highlighter-rouge">step</code>만큼의 수만큼 건너뛰는 Tensor를 생성해주는 역할을 합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="s">'''
 0
 2
 4
 6
 8
[torch.FloatTensor of size 5]
'''</span>
</code></pre></div></div>

<p>즉, 원하는 숫자 범위에서 <code class="highlighter-rouge">step</code>만큼 일정한 간격을 두는 데이터를 만들 때 사용하면 좋겠죠? 참고로 마지막으로 남아 떨어지지 않는 수는 생성하지 않는 다는 것을 명심 하셔야 될것같습니다.</p>

<h3 id="torchlinspacestart-end-steps">torch.linspace(start, end, steps)</h3>

<p><code class="highlighter-rouge">torch.linspace()</code>하고 <code class="highlighter-rouge">torch.arange()</code>하고의 차이를 헷갈리시는 분들도 계실 겁니다. <code class="highlighter-rouge">torch.linspace()</code>는 <code class="highlighter-rouge">start</code>하고 <code class="highlighter-rouge">end</code>사이의 수로 <code class="highlighter-rouge">steps</code>수 만큼 일정한 간격을 갖는 수를 생성해주는 역할을 합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
<span class="s">'''
  0.0000
  1.4286
  2.8571
  4.2857
  5.7143
  7.1429
  8.5714
 10.0000
[torch.FloatTensor of size 8]
'''</span>
</code></pre></div></div>

<h2 id="numpy타입과-tensor타입의-호환">Numpy타입과 Tensor타입의 호환</h2>

<h3 id="torchfrom_numpyx">torch.from_numpy(x)</h3>

<p><code class="highlighter-rouge">torch.from_numpy(x)</code>는 numpy로 만든 데이터를 PyTorch에서 사용이 가능한 Tensor로 변환해주는 메소드입니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">numpy_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="nb">buffer</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]))</span>
<span class="n">tensor_data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">numpy_data</span><span class="p">)</span> 
</code></pre></div></div>

<h3 id="tensornumpy">Tensor.numpy()</h3>

<p><code class="highlighter-rouge">Tensor.numpy()</code>는 Tensor 타입의 데이터를 numpy 타입의 데이터로 바꾸는 메소드입니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">numpy_data</span> <span class="o">=</span> <span class="n">tensor_data</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
</code></pre></div></div>

<h2 id="그-외">그 외</h2>

<h3 id="tensorcuda">Tensor.cuda()</h3>

<p><code class="highlighter-rouge">Tensor.cuda()</code>는 GPU연산을 지원하는 디바이스에서 GPU연산용으로 변환하기 위한 메소드입니다. <strong><em>단, 사용시 <code class="highlighter-rouge">torch.cuda.is_available()</code>로 디바이스가 GPU연산이 가능한지 확인하고 사용할 수 있도록 하는 것이 좋습니다.</em></strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">():</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">cuda</span><span class="p">()</span>
</code></pre></div></div>

<h3 id="tensorsize">Tensor.size()</h3>

<p><code class="highlighter-rouge">Tensor.size()</code>는 해당하는 텐서의 사이즈를 확인할 수 있는 메소드입니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="s">'''
torch.Size([2, 3])
'''</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">Tensor.size(n-dim)</code>에 <code class="highlighter-rouge">n-dim</code>의 매개변수로 차원의 인덱스를 넘겨주면 해당하는 차원의 크기를 알아올 수도 있습니다.</p>

<hr />
<h1 id="마치며">마치며</h1>

<p>기본적으로 PyTorch에서 자주 쓰는 메소드들에 대해서 알아 보았습니다. 이것 외에도 Tensor끼리 나누고 붙이고하는 메소드나 차원을 줄이고하는 메소드들에 대해서는 다음시간에 알아보도록 하겠습니다. 조금이나마 모두에게 도움이 되었으면 좋겠습니다. 감사합니다.</p>

	  ]]></description>
	</item>

	<item>
	  <title>PyTorch에 관하여</title>
	  <link>https://hashbox.github.io/PyTorch%EA%B4%80%ED%95%98%EC%97%AC</link>
		
				
		
				
						<author>한지승(Jee Seung, Han)</author>
				
		
	  <pubDate>2018-01-08T10:18:00+00:00</pubDate>
	  <guid>https://hashbox.github.io/PyTorch%EA%B4%80%ED%95%98%EC%97%AC</guid>
	  <description><![CDATA[
	     <h1 id="pytorch에-관하여">PyTorch에 관하여</h1>

<blockquote>
  <p>기존 딥러닝 라이브러리를 Google의 Tensorflow를 사용했었습니다. <del>많이 사용해본 것은 아닙니다ㅠ</del> 그러던 중 PyTorch라는 새로운 라이브러리를 알게 되었고 조금씩 공부해가면서 충분히 매리트가 더 있다는게 느껴졌습니다. 그래서 공부하며 정리한 내용을 포스팅할 예정입니다. 아직은 미숙한 내용이나 틀린 내용이 있을 수 있습니다. 수정해야할 내용이 보인다면 알려주시면 감사하겠습니다.</p>
</blockquote>

<h2 id="python-first">Python First</h2>

<p><a href="http://pytorch.org/about/">PyTorch</a>에서 확인을 할 수 있듯이 PyTorch에서 가장 강조하는 부분은 <strong>“Python first”</strong>입니다. 기존에 사용하던 Tensorflow와는 다르게 PyTorch는 Python에 친화적입니다. Tensorflow는 대부분의 라이브러리가 C/C++로 구현이 되어있고 인터페이스를 통해 Python에서 돌아가고 있습니다. 반면에, PyTorch는 텐서연산(C/C++구현)을 제외하고는 직접 구현되어있다 합니다. 그렇기 때문에 다른 Python의 다른 패키지 사용이 자유롭습니다.</p>

<h2 id="직관적인-흐름">직관적인 흐름</h2>

<p>Tensorflow와는 다르다고 느꼈던 점은 네트워크를 구성할 때 구성하는 내용의 흐름이 보인다는 것입니다. 단계적으로 어떤 네트워크를 사용했고, 어떤 활성화 함수를 적용했으며, 순서가 어떻게 되는지 직관적으로 한번에 이해할 수 있었습니다. 현재는 <code class="highlighter-rouge">nn.Sequencial()</code> 함수를 통해 순서를 정해주거나, <code class="highlighter-rouge">nn.Module</code>을 상속받은 클래스 내에 <code class="highlighter-rouge">forward()</code> 함수를 오버라이딩해서 네트워크가 어떻게 구성되었는지 알 수 있습니다. 결론적으로는 직관적인 흐름으로 표현이 가능하고, 코드가 간결하기 때문에 구현하는데 있어서 다른 프레임워크들 보다 엄청난 장점으로 작용합니다.</p>

<blockquote>
  <p>아직까지는 이 두가지 방법이 어떻게 다르며, 어쩔때 사용하는 것이 좋은지 아니면 단순 구현방법의 차이인지 더 자세히 알아보고 내용을 추가하도록 하겠습니다.</p>
</blockquote>

<h4 id="내용-추가">내용 추가</h4>

<blockquote>
  <p>기능상 <code class="highlighter-rouge">nn.Sequencial()</code>하고 <code class="highlighter-rouge">forward()</code>하고의 차이점은 크게 없으나 <code class="highlighter-rouge">nn.Sequencial()</code>과 같은 경우에는 레이어와 레이어 사이에 중간처리가 필요하지 않은 작업일 경우 사용해도 무방하지만, 예를들어 레이어와 레이어 사이에 차원의 변경이 필요한다든지(<code class="highlighter-rouge">view()</code>와 같은 작업이라든지) 중간처리가 필요할 경우에는 <code class="highlighter-rouge">forward()</code>에서 작업을 해야하는 부분 때문에 필요한걸 확인했습니다. 위와같은 문제 이외에는 어떠한 부분으로 구현을 하는지에 대한 부분은 개인의 취향에 따라 결정하시면 될 것 같습니다.</p>
</blockquote>

<h2 id="그래디언트를-자동-계산">그래디언트를 자동 계산</h2>

<p>Tensorflow와는 다르게 PyTorch는 Tensor 변수를 <code class="highlighter-rouge">nn.autograd</code>패키지 안에 있는 <code class="highlighter-rouge">Variable()</code>이라는 함수로 wrapping하여 사용합니다. 이는 Tensor의 변화를 자동으로 기록하고 그래디언트를 자동으로 계산해주는 역할을 해줍니다.</p>

<h2 id="빠른-연산속도">빠른 연산속도</h2>

<p>PyTorch는 다른 프레임워크들보다 메모리를 효율적으로 사용하기 때문이라고 합니다. 뿐만아니라 DCG(Dynamic Computation Graph)를 지원하기 때문에 CPU연산에서는 <em>10배</em>, GPU연산에서 <em>100배</em> 의 차이를 보인다고 합니다.</p>

<hr />

<h1 id="마치며">마치며</h1>

<p>이번 포스팅에는 간단하게 PyTorch에 장점에 대해서 알아보았습니다. PyTorch를 공부하면서 Tensorflow보다 더 직관적이고 빠른 성능에 더 깊이있게 공부하고 싶다는 생각이 들었습니다. 다음에는 더 자세한 내용으로 찾아 뵙겠습니다. 감사합니다.</p>

	  ]]></description>
	</item>

	<item>
	  <title>CentOS7 + Apache + Tomcat8 연동(mod_jk)</title>
	  <link>https://hashbox.github.io/Apache-Tomcat-%EC%97%B0%EB%8F%99</link>
		
				
		
				
						<author>한지승(Jee Seung, Han)</author>
				
		
	  <pubDate>2017-06-24T10:18:00+00:00</pubDate>
	  <guid>https://hashbox.github.io/Apache-Tomcat-%EC%97%B0%EB%8F%99</guid>
	  <description><![CDATA[
	     <h1 id="개요">개요</h1>

<p>이번에는 CentOS7 환경에서 아파치 <code class="highlighter-rouge">httpd</code>와 <code class="highlighter-rouge">tomcat8</code>을 연동하는 방법에 대해서 알아보도록 하겠습니다. 평소 웹 환경을 구축해야하는 경우가 많은데 매번 할 때마다 까먹고 찾고 하는 시간이 너무 오래 걸리는 것같아 이번에 다시 환경을 만들면서 설치 순서를 기록으로 남겼습니다. 기본적인 환경 구축만을 목표로 하기 때문에 간단하고 추가되는 설정은 없습니다. 환경을 구축하고 난 뒤에 필요하신 옵션을 추가해서 사용하세요~! 지금 부터 알아보도록 하겠습니다.</p>

<hr />

<h2 id="환경을-구축하기-위한-패키지-및-apache-httpd-설치">환경을 구축하기 위한 패키지 및 Apache Httpd 설치</h2>

<p>우선 환경을 구축하기 위해서 필요로 하는 패키지를 한번에 설치하도록 하겠습니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yum install <span class="nt">-y</span> gcc gcc-c++ httpd-devel java-1.8.0-openjdk-devel.x86_64 wget libtool make
</code></pre></div></div>

<p>기본적으로 <code class="highlighter-rouge">libtool</code>, <code class="highlighter-rouge">gcc</code>환경과 <code class="highlighter-rouge">java jdk</code>가 설치 되어 있어야하며, <code class="highlighter-rouge">wget</code>이나 <code class="highlighter-rouge">make</code>는 설치가 안되 있으신 분들은 위해 넣었습니다. 이와 함께 제일 설치하기 쉬운 아파치 설치는 <code class="highlighter-rouge">httpd-devel</code>을 통해서 설치가 가능합니다. 위 명령어를 이용하면 환경을 구축하는데 있어 필요로하는 패키지들과 <code class="highlighter-rouge">apache</code>가 설치가 완료 하셨습니다.</p>

<h2 id="tomcat8-설치">Tomcat8 설치</h2>

<p>저는 <code class="highlighter-rouge">tomcat8</code>을 설치 하게 되었는데요. 이는 http://tomcat.apache.org/download-80.cgi에 들어가시면 최신버전의 톰캣 <code class="highlighter-rouge">tar.gz</code>압축 파일을 받으실 수 있습니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget http://mirror.navercorp.com/apache/tomcat/tomcat-8/v8.5.23/bin/apache-tomcat-8.5.23.tar.gz
<span class="nb">tar </span>zxvf apache-tomcat-8.5.23.tar.gz
mv apache-tomcat-8.5.23.tar.gz /opt/tomcat
</code></pre></div></div>

<p>위와 같은 명령어를 통해서 현재 폴더에 톰캣 압축파일을 받아옵니다.  그 후 <code class="highlighter-rouge">tar</code>명령어를 통해 압축을 풀어주고 난 뒤에 해당 폴더를 그대로 <code class="highlighter-rouge">/opt/tomcat</code>으로 이동을 시켜줍니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>groupadd tomcat
<span class="nb">sudo </span>useradd <span class="nt">-M</span> <span class="nt">-s</span> /bin/nologin <span class="nt">-g</span> tomcat <span class="nt">-d</span> /opt/tomcat tomcat
<span class="nb">sudo </span>chown <span class="nt">-R</span> tomcat:tomcat /opt/tomcat
</code></pre></div></div>

<p>그 후 톰캣을 사용하는 유저를 지정해주셔야합니다. <code class="highlighter-rouge">tomcat</code>그룹과 <code class="highlighter-rouge">tomcat</code>유저를 생성하면서 구동파일들을 옮겨놨던 <code class="highlighter-rouge">/opt/tomcat</code>을 지정해주고, 해당 폴더의 소유자를 <code class="highlighter-rouge">tomcat</code>으로 변경해주시면 됩니다.</p>

<p>그 다음에는 톰캣을 서비스에서 등록하고 서버가 부팅될 때 바로 켜지도록 설정을 할 것입니다. 수동으로 켜고 끄시는 것만 하실 경우에는 서비스만 등록하시고 <code class="highlighter-rouge">chkconfig</code> 명령어만 입력 안하셔도 괜찮습니다.</p>

<h3 id="tomcat-서비스-파일-생성">Tomcat 서비스 파일 생성</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vim /etc/systemd/system/tomcat.service
</code></pre></div></div>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span>Unit<span class="p">]</span>
Description<span class="p">=</span>Apache Tomcat Web Application Container
After<span class="p">=</span>syslog<span class="p">.</span>target network<span class="p">.</span>target

<span class="p">[</span>Service<span class="p">]</span>
Type<span class="p">=</span>forking

Environment<span class="p">=</span>JAVA_HOME<span class="p">=</span><span class="sr">/usr/</span>lib<span class="sr">/jvm/</span>java<span class="m">-1</span><span class="p">.</span><span class="m">8</span><span class="p">.</span><span class="m">0</span><span class="p">-</span>openjdk<span class="m">-1</span><span class="p">.</span><span class="m">8</span><span class="p">.</span><span class="m">0</span><span class="p">.</span><span class="m">151-1</span><span class="p">.</span>b12<span class="p">.</span>el7_4<span class="p">.</span>x86_64
Environment<span class="p">=</span>CATALINA_PID<span class="p">=</span><span class="sr">/opt/</span>tomcat<span class="sr">/temp/</span>tomcat<span class="p">.</span>pid
Environment<span class="p">=</span>CATALINA_HOME<span class="p">=</span><span class="sr">/opt/</span>tomcat
Environment<span class="p">=</span>CATALINA_BASE<span class="p">=</span><span class="sr">/opt/</span>tomcat
Environment<span class="p">=</span><span class="s1">'CATALINA_OPTS=-Xms512M -Xmx1024M -server -XX:+UseParallelGC'</span>
Environment<span class="p">=</span><span class="s1">'JAVA_OPTS=-Djava.awt.headless=true -Djava.security.egd=file:/dev/./urandom'</span>

ExecStart<span class="p">=</span><span class="sr">/opt/</span>tomcat<span class="sr">/bin/</span>startup<span class="p">.</span><span class="k">sh</span>
ExecStop<span class="p">=</span><span class="sr">/bin/</span>kill <span class="m">-15</span> $MAINPID

<span class="nb">User</span><span class="p">=</span>tomcat
Group<span class="p">=</span>tomcat
UMask<span class="p">=</span><span class="m">0007</span>
RestartSec<span class="p">=</span><span class="m">10</span>
Restart<span class="p">=</span>always

<span class="p">[</span>Install<span class="p">]</span>
WantedBy<span class="p">=</span>multi<span class="p">-</span>user<span class="p">.</span>target
</code></pre></div></div>

<p><code class="highlighter-rouge">JAVA_HOME</code>과 같은 경우에는 혹시나 다를까 싶어 해당하는 경로를 가져오는 방법까지 첨부합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>which javac
readlink <span class="nt">-f</span> <span class="o">{</span>which javac로 나온 경로를 입력<span class="o">}</span>
</code></pre></div></div>

<p>위와 같은 명령어로 <code class="highlighter-rouge">java</code>가 불려지는 파일 링크의 절대경로를 읽어 올 수 있습니다. 명령어로 얻은 주소에서 <code class="highlighter-rouge">bin</code>경로 전까지의 경로를 <code class="highlighter-rouge">JAVA_HOME</code>에 입력하시면됩니다.</p>

<h3 id="tomcat-서버-부팅시-자동시작">Tomcat 서버 부팅시 자동시작</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>chkconfig tomcat on
</code></pre></div></div>

<p><code class="highlighter-rouge">chkconfig</code>를 통해서 <code class="highlighter-rouge">tomcat</code>서비스가 자동으로 시작되도록 추가해주시면 됩니다.</p>

<h2 id="apache-httpd와-tomcat-연동mod_jk">Apache Httpd와 Tomcat 연동(mod_jk)</h2>

<p><code class="highlighter-rouge">Apache</code>와 <code class="highlighter-rouge">tomcat</code>을 연동하기 위해서는 모듈이 필요한데요. 가장 많이 사용하는 <code class="highlighter-rouge">mod_jk</code>를 이용해서 연동해보도록 하겠습니다. 우선 <code class="highlighter-rouge">mod_jk</code>를 설치파일을 다운 받아야합니다. 파일은 http://tomcat.apache.org/download-connectors.cgi에서 다운로드 받으실 수 있습니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget http://apache.mirror.cdnetworks.com/tomcat/tomcat-connectors/jk/tomcat-connectors-1.2.42-src.tar.gz
<span class="nb">tar </span>zxvf tomcat-connectors-1.2.42-src.tar.gz
<span class="nb">cd </span>tomcat-connectors-1.2.42-src/native/
</code></pre></div></div>

<p>다운로드를 받으신 후 압축을 푸신다음에 해당 폴더에 <code class="highlighter-rouge">native</code>폴더로 들어가셔서 설치를 하셔야 합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./buildconf.sh
./configure <span class="nt">--with-apxs</span><span class="o">=</span>/usr/bin/apxs
make
make install
</code></pre></div></div>

<p>위와 같은 순서대로 설치를 진행해주세요. 혹시나 다른 리눅스 환경에서 설치를 하시는 경우에는 <code class="highlighter-rouge">--with-apxs</code>의 폴더 위치가 다를 수 있습니다. 다른 환경에서 진행 시 <code class="highlighter-rouge">apxs</code>를 찾지 못하는 오류가 있으실 경우에는 리눅스 환경에 맞는 경로를 따로 찾으셔서 적용해주세요. CentOS의 경우에는 위 명령어대로 설치하시면 문제 없이 설치가 완료를 할 수 있습니다.</p>

<h3 id="연동-설정">연동 설정</h3>

<p>설치를 모두 완료 하셨으니 인제 <code class="highlighter-rouge">httpd</code>와 <code class="highlighter-rouge">tomcat</code>간 설정을 해주셔야합니다. 우선 아파치 설정을 잡을 것입니다. CentOS를 사용하시는 경우 아파치 관련 폴더인  <code class="highlighter-rouge">/etc/httpd/</code>에서 폴더 구조가 <code class="highlighter-rouge">conf</code>, <code class="highlighter-rouge">conf.d</code>, <code class="highlighter-rouge">conf.modules.d</code>와 같이 나뉘어져 있습니다. <code class="highlighter-rouge">conf</code>는 아파치의 설정파일만 존재하도록 구성되어있고 추가적인 모듈별 설정 같은 것을 <code class="highlighter-rouge">conf.d</code>에 생성하셔서 사용하시면 자동으로 불러와 적용되어집니다. <code class="highlighter-rouge">conf.modules.d</code>와 같은 경우에는 사용할 모듈을 불러오는 설정만 적용하는 파일들을 관리하는 폴더입니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> /etc/httpd/conf.modules.d/
vim 00-jk.conf
</code></pre></div></div>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code>LoadModule jk_module modules/mod_jk<span class="p">.</span><span class="k">so</span>
</code></pre></div></div>

<p>우선 <code class="highlighter-rouge">conf.module.d</code>폴더에 <code class="highlighter-rouge">mod_jk</code>관련 모듈을 불러오기 위해 <code class="highlighter-rouge">00-jk.conf</code>파일을 생성하고 <code class="highlighter-rouge">LoadModule ~~</code>을 입력하고 저장해주세요. 이는 방금전 설치한 <code class="highlighter-rouge">mod_jk</code>모듈을 불러와 <code class="highlighter-rouge">jk_module</code>이라는 이름으로 명명하는 구문입니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> /etc/httpd/conf.d/
vim httpd-jk.conf
</code></pre></div></div>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">&lt;</span>IfModule jk_module<span class="p">&gt;</span>

    # We need <span class="k">a</span> workers <span class="k">file</span> exactly once
    # and <span class="k">in</span> the global server
    JkWorkersFile <span class="k">conf</span><span class="p">.</span><span class="k">d</span>/workers<span class="p">.</span>properties

    JkLogStampFormat <span class="s2">"[%a %b %d %H:%M:%S %Y] "</span>
    # Our JK error log
    # You can <span class="p">(</span>and should<span class="p">)</span> use rotatelogs here
    JkLogFile logs/mod_jk<span class="p">.</span>log

    # Our JK log level <span class="p">(</span>trace<span class="p">,</span><span class="k">debug</span><span class="p">,</span>info<span class="p">,</span>warn<span class="p">,</span>error<span class="p">)</span>
    JkLogLevel info

    # Our JK shared memory <span class="k">file</span>
    JkShmFile logs/mod_jk<span class="p">.</span>shm

    # If you want <span class="k">to</span> <span class="k">put</span> <span class="k">all</span> mounts into an external <span class="k">file</span>
    # that gets reloaded automatically after <span class="k">changes</span>
    # <span class="p">(</span>with <span class="k">a</span> default latency of <span class="m">1</span> minute<span class="p">),</span>
    # you can define the name of the <span class="k">file</span> here<span class="p">.</span>
    JkMountFile <span class="k">conf</span><span class="p">.</span><span class="k">d</span>/uriworkermap<span class="p">.</span>properties

<span class="p">&lt;</span>/IfModule<span class="p">&gt;</span>
</code></pre></div></div>

<p>그 후 불러온 모듈에 대한 설정을 진행해 줍니다. 주의해서 보셔야 할 것은 <code class="highlighter-rouge">JkWorkersFile</code>과 <code class="highlighter-rouge">JkMountFile</code>입니다. 전자는 톰캣 서버들을 각각 설정하는 역할을 해주며, 후자는 특정 패턴을 가지는 파일을 요청했을 때 서비스하고자 하는 톰캣 서버를 지정하는 역할을 합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> /etc/httpd/conf.d/
vim workers.properties
</code></pre></div></div>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code>worker<span class="p">.</span>list<span class="p">=</span>instance1<span class="p">,</span>instance2<span class="p">,</span>instance3

worker<span class="p">.</span>instance1<span class="p">.</span>port<span class="p">=</span><span class="m">8109</span>
worker<span class="p">.</span>instance1<span class="p">.</span>host<span class="p">=</span>localhost
worker<span class="p">.</span>instance1<span class="p">.</span>type<span class="p">=</span>ajp13
worker<span class="p">.</span>instance1<span class="p">.</span>lbfactor<span class="p">=</span><span class="m">1</span>

worker<span class="p">.</span>instance2<span class="p">.</span>port<span class="p">=</span><span class="m">8209</span>
worker<span class="p">.</span>instance2<span class="p">.</span>host<span class="p">=</span>localhost
worker<span class="p">.</span>instance2<span class="p">.</span>type<span class="p">=</span>ajp13
worker<span class="p">.</span>instance2<span class="p">.</span>lbfactor<span class="p">=</span><span class="m">1</span>

worker<span class="p">.</span>instance3<span class="p">.</span>port<span class="p">=</span><span class="m">8309</span>
worker<span class="p">.</span>instance3<span class="p">.</span>host<span class="p">=</span>localhost
worker<span class="p">.</span>instance3<span class="p">.</span>type<span class="p">=</span>ajp13
worker<span class="p">.</span>instance3<span class="p">.</span>lbfactor<span class="p">=</span><span class="m">1</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">workers.properties</code>파일은 위와같이 톰캣서버가 3개일 경우 톰캣서버의 이름들을 설정하고 해당 서버에 대한 설정을 이루도록 되어있습니다. 구축하시려는 환경에 맞게 옵션을 설정해주시면 됩니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vim uriworkermap.properties
</code></pre></div></div>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*<span class="p">.</span>jsp<span class="p">=</span>instance1
/*<span class="p">.</span>png<span class="p">=</span>instance2
/*<span class="p">.</span>css<span class="p">=</span>instance3
</code></pre></div></div>

<p><code class="highlighter-rouge">uriworkermap.properties</code>에는 특정 파일에 대해서 어떤 톰캣서버가 서비스할 것인지 맵핑하실 수 있습니다. 해당하는 파일들을 따로 나누어 관리하는 이유는 톰캣이 기본 10분마다 다시불러와 적용하기 때문에 톰캣 설정 변경을 위해 서비스를 재시작하지 않으셔도 적용이 가능하다는 이점이있기 때문입니다.</p>

<h2 id="서비스-재시작">서비스 재시작</h2>

<p>인제 모든 설정을 마무리했습니다. <code class="highlighter-rouge">httpd</code>서비스와 <code class="highlighter-rouge">tomcat</code>서비스를 재시작하셔서 설정된 내용들을 적용하시면 됩니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>service httpd restart
service tomcat restart
</code></pre></div></div>

<h3 id="팁1-연동-설정이-정상적으로-적용이-되는지-확인하는-방법">팁1: 연동 설정이 정상적으로 적용이 되는지 확인하는 방법</h3>

<p>아파치 <code class="highlighter-rouge">httpd</code>에는 정상적으로 설정파일들이 정상적인 Syntax를 가지고 있는지 확인하는 명령어를 내장하고 있습니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apachectl configtest
</code></pre></div></div>

<h3 id="팁2-톰캣-인코딩설정">팁2: 톰캣 인코딩설정</h3>

<p>톰캣에서 한글을 사용할 때 인코딩 문제로 깨지는 문제가 발생하실 수 있기 때문에 인코딩을 설정을 하셔야 합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vim /opt/tomcat/conf/server.xml
</code></pre></div></div>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span>생략<span class="p">)</span>
<span class="p">&lt;</span>Connector port<span class="p">=</span><span class="s2">"8009"</span> protocol<span class="p">=</span><span class="s2">"AJP/1.3"</span> redirectPort<span class="p">=</span><span class="s2">"8443"</span> URIEncoding<span class="p">=</span><span class="s2">"UTF-8"</span> /<span class="p">&gt;</span>
<span class="p">(</span>생략<span class="p">)</span>
</code></pre></div></div>

<p>위와 같이 AJP 커넥터에 <code class="highlighter-rouge">URIEncoding="UTF-8"</code>을 적용하시면 됩니다.</p>

<hr />

<h1 id="마치며">마치며</h1>

<p>매번 환경을 구축할 때마다 괜한 곳에서 헤매는 경우가 많아 제가 많이 사용하는 서버환경에서 구축하는 방법을 정리해보았습니다. 여러번 시도하면서 군더더기 없는 설치를 위해 여러번을 엎고 다시 기록했습니다. 많은 분들께서 도움이 되셨으면 좋겠습니다. 감사합니다!</p>

	  ]]></description>
	</item>

	<item>
	  <title>Java의 Static 바로알기</title>
	  <link>https://hashbox.github.io/Java-Static-%EB%B0%94%EB%A1%9C%EC%95%8C%EA%B8%B0</link>
		
				
		
				
						<author>한지승(Jee Seung, Han)</author>
				
		
	  <pubDate>2017-06-20T20:10:00+00:00</pubDate>
	  <guid>https://hashbox.github.io/Java-Static-%EB%B0%94%EB%A1%9C%EC%95%8C%EA%B8%B0</guid>
	  <description><![CDATA[
	     <h1 id="개요">개요</h1>

<p>Java를 처음 배우게 되는 것 중에 하나는 <code class="highlighter-rouge">static</code>이라는 키워드일것입니다. 또한 Java에 Main 클래스에서 항상 존재하는 <code class="highlighter-rouge">static</code> 키워드는 누구나 익숙하실 겁니다. 하지만 생각보다 <code class="highlighter-rouge">static</code>키워드에 대해서 어쩔때 쓴다 정도는 모두 알고 계시지만 깊이있는 특성을 모르시는 분들이 많습니다. 저 또한 무분별하게 사용했었던 적이 있습니다.  <code class="highlighter-rouge">static</code>키워드의 특성을 자세히 알게 되면 조금 더 활용성 높게 사용하실 수 있습니다. 심지어 취업 면접을 보면서 <code class="highlighter-rouge">static</code>키워드에 대해서 심도 있게 아는지에 대한 면접질문을 많이 받았을 정도로 중요한 부분이라 생각합니다. 지금부터 자세히 알아보도록 하겠습니다.</p>

<p><br /></p>

<hr />

<p><br /></p>

<h2 id="static">static</h2>

<p>처음 Java를 배우시는 분들이 익숙하면서 어쩔때 사용하는지 모르는 키워드는 <code class="highlighter-rouge">static</code> 키워드라 생각합니다. 왜냐하면 Java 프로젝트를 처음 만들고 마주하는 것은 다음과 같은 화면이기 때문이죠.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello World!"</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>저 또한 대학교시절 Java를 처음 배우면서 <code class="highlighter-rouge">main</code>함수에 코딩을 하면서 연습을 했었습니다. 그러다가 자바 메소드에 대해서 알게 되면서 만들어서 사용하려고 하면 빨간줄이 <em>찍</em> 그어지면서 메소드를 호출할 수 없게 되고, 이를 해결하려고 방금 만든 함수에 <code class="highlighter-rouge">static</code>키워드를 붙임으로써 사용이 되는구나하면서 넘어갔던 적이 있습니다. 하지만 이와 같이 작동이 되어야 하는 이유는 생각보다 간단한 이유입니다.</p>

<p><br /></p>

<p><code class="highlighter-rouge">static</code>키워드를 붙인 멤버변수나 메소드와 안 붙인 멤버변수나 메소드와의 <strong>차이점</strong>은 메모리에 적재되는 시기에서부터 시작됩니다. 기본적으로 Java는 객체지향언어로 클래스를 작성하고 해당 클래스를 인스턴스화(객체화)해서 사용하는 형태로 이루어집니다. 여러분들께서 클래스를 작성하고 사용하기 위해서는 <code class="highlighter-rouge">new MyClass()</code>와 같은 형태로 인스턴스를 생성하고 사용을 하시는 이유가 해당 클래스로 인스턴스를 생성하고 생성된 인스턴스로 사용하시기 때문입니다. 그렇기 때문에 인스턴스를 생성하지 않고는 사용하실 경우 에러를 <em>뿜뿜</em>하신다는 것은 모두 알고 계실 것입니다. 이말은 즉, 인스턴스 생성을 할 때 해당 객체가 메모리가 적재 된다는 것을 아실 수 있으십니다.</p>

<p>그렇타면, Java를 배우면서 한번쯤은 모두 써보셨을 만한 Math 클래스는 어떤가요? 실습예제대로 따라하시다보니 잘 모르실 수도 있으시지만 Math 클래스 같은 경우에는 <code class="highlighter-rouge">new Math()</code>와 같은 인스턴스 생성을 하지 않고 바로 <code class="highlighter-rouge">Math.abs()</code>와 같은 형태로 바로 사용하셨을 겁니다. 그렇타면 Math 클래스는 어떻게 사용이 가능한걸까요?</p>

<p><br /></p>

<h3 id="static의-메모리-적재-시기">static의 메모리 적재 시기</h3>

<p>일단 결론부터 말씀드리면 Math 클래스는 모두 <code class="highlighter-rouge">static</code>키워드로 이루어져 있기 때문에 가능합니다. 맞습니다. <code class="highlighter-rouge">static</code>키워드를 붙인 멤버변수나 메소드는 인스턴스를 생성하지도 않아도, JVM이 클래스를 읽어들일 때 이미 자동적으로 메모리에 적재가 일어납니다. 그렇기 때문에 <code class="highlighter-rouge">static</code>키워드를 붙인 멤버변수나 메소드는 인스턴스 생성을 하지 않고도 사용이 가능한 것입니다. 그렇타면 <code class="highlighter-rouge">main(String[] args)</code> 메소드가 <code class="highlighter-rouge">static</code>이 붙는 이유가 이해가 되시나요? 맞습니다, <code class="highlighter-rouge">main(String[] args)</code>는 자바 어플리케이션이 실행될 때 처음으로 실행되는 메소드이기 때문에 메모리에 적재가 되어있어야 실행이 가능하기 때문입니다. 이제 <code class="highlighter-rouge">static</code>을 붙였을 때의 기본적인 원리를 알게되었습니다. 인제 이러한 원리로 인해 어떤 특성을 갖게 되는지 알아 볼까요?</p>

<p><br /></p>

<hr />

<p><br /></p>

<h2 id="static의-특성-및-사용">static의 특성 및 사용</h2>

<h3 id="클래스의-인스턴스-간-공유변수">클래스의 인스턴스 간 공유변수</h3>

<p>클래스를 작성하고 여러 인스턴스를 만들어 사용할 때 모두 똑같은 값을 유지해야하는 경우가 있습니다. 이럴 때 해당 멤버 변수를 <code class="highlighter-rouge">static</code>으로 선언하시면 됩니다. 해당 클래스에서 <code class="highlighter-rouge">static</code>키워드가 붙은 해당 멤버 변수는 인스턴스가 생성되기 전에 메모리를 할당 받기 때문에 모든 인스턴스가 똑같은 멤버변수를 바라보게 됩니다.</p>

<p><br /></p>

<h3 id="static키워드가-붙은-메소드는-static이-것만-사용-가능하다">static키워드가 붙은 메소드는 static이 것만 사용 가능하다!</h3>

<p>그렇습니다. 결론부터 말하면은 <code class="highlighter-rouge">static</code>이 붙은 메소드는 <code class="highlighter-rouge">static</code>이 붙은 멤버변수나 메소드만 사용이 가능합니다. 왜그럴까요? 생각보다 간단한 원리입니다. <code class="highlighter-rouge">static</code>키워드가 붙은 메소드는 인스턴스가 생성되기도 전에 메모리에 적재돼고 사용이 가능해야 합니다. 하지만 해당 메소드 내부에서 <code class="highlighter-rouge">static</code>이 붙지 않은 메소드나 멤버변수를 사용하게 되면? 당연히 에러가 <em>찍</em> 나올 겁니다. 왜냐하면 메모리에 적재되지도 않은 멤버변수나 메소드를 호출하려고 했기 때문입니다. 그렇기 때문에 <code class="highlighter-rouge">static</code>키워드가 붙은 메소드는 사용하는 것들도 <code class="highlighter-rouge">static</code>이 붙어야합니다.</p>

<p><br /></p>

<h3 id="필자의-주관적인-사용-지침">필자의 주관적인 사용 지침</h3>

<p><code class="highlighter-rouge">static</code>키워드에 대해서 알아 보았습니다. 그렇타면 언제 사용하는 것이 좋을까요? 우선 위에서 말씀 드렸듯이 인스턴스간에 공유하는 값이나 공통된 값을 유지해야하는 경우에는 <code class="highlighter-rouge">static</code>사용을 고려하면 되겠습니다.</p>

<p>또한, 작성한 메소드가 멤버변수를 사용하지 않고 파라미터만 사용(메소드 내 변수만)하는 경우 메소드에 <code class="highlighter-rouge">static</code>키워드를 고려해보는 것이 좋지 않을까 싶습니다. <code class="highlighter-rouge">static</code> 키워드를 붙인 메소드는 호출시간이 안 붙인 메소드에 비해 짧기 때문입니다. 기본적으로 <code class="highlighter-rouge">static</code> 키워드를 안 붙인 메소드는 해당 인스턴스의 메소드를 찾는 과정이 일어나기 때문에 비교적 오래 걸리기 때문입니다.</p>

<p>나아가 위와 같은 이유로 유틸리티성이 강한 클래스에 <code class="highlighter-rouge">static</code>을 붙이는 것을 고려해보는 것이 좋습니다. 유틸리티성이 강한 클래스는 인스턴스를 하지 않고도 여러 곳에서 호출이 일어나기 때문에 조금더 호출시간을 줄이고 빠르게 사용하기 위함입니다.</p>

<p><br /></p>

<hr />

<p><br /></p>

<h1 id="마치며">마치며</h1>

<p><code class="highlighter-rouge">static</code>키워드에 대해서 깊이있게 아는 것이 중요하다 생각합니다. 조금이나마 알기 쉽게 또 도움이 될 수 있는 포스트였으면 좋겠습니다. 추가적으로 깊이 있는 내용이 필요하다면 댓글을 달아주시면 저 또한 많은 도움이 돼지 않을까 싶습니다. 감사합니다!</p>

	  ]]></description>
	</item>

	<item>
	  <title>Python 기본 환경 구축하기(pyenv, virtualenv, autoenv)</title>
	  <link>https://hashbox.github.io/Python-%EA%B8%B0%EB%B3%B8%ED%99%98%EA%B2%BD%EA%B5%AC%EC%B6%95</link>
		
				
		
				
						<author>한지승(Jee Seung, Han)</author>
				
		
	  <pubDate>2017-06-15T10:08:00+00:00</pubDate>
	  <guid>https://hashbox.github.io/Python-%EA%B8%B0%EB%B3%B8%ED%99%98%EA%B2%BD%EA%B5%AC%EC%B6%95</guid>
	  <description><![CDATA[
	     <h1 id="개요">개요</h1>

<p>Python을 시작하신지 얼마 안되신 분들은 Python을 사용하기 전에 <code class="highlighter-rouge">pyenv</code>, <code class="highlighter-rouge">virtualenv</code>, <code class="highlighter-rouge">autoenv</code>를 설치하는 이유에 대해서 잘 모르실수도 있습니다. 저또한 처음 시작할 때 굳이 번거롭게 설치할 필요가 있나 했던 적이 있습니다. 지금와서 생각해보면 그런 생각을 할 수 밖에 없는 이유는 대부분 Python 단일 프로젝트로 작업하시거나 또는, 그냥 Python의 패키지들을 전역으로 설치해놓코 사용하시는데 문제가 없으신 분들이라 생각됩니다. 지금부터  <code class="highlighter-rouge">pyenv</code>, <code class="highlighter-rouge">virtualenv</code>, <code class="highlighter-rouge">autoenv</code>가 왜 필요한지에 대해서 설명드리도록 하겠습니다</p>

<p><br /></p>

<hr />

<p><br /></p>

<h2 id="기본적인-이유">기본적인 이유</h2>

<p>일단 Python을 설치하실 때 2.7버전때와 3.6버전으로 두가지로 나뉘어져 있는 것을 알 수 있습니다. 두 버전간에 매우 큰 변화가 있었기 때문에 기존에 존재하던 패키지들과의 호환이 안맞기도하고 없어진 기능들도 있고 이런 저런 이유들로 공존하고 있는 상황입니다. 그렇기 때문에 처음 설치하실 때도 무엇을 깔아야 하는지 모르신 분들도 많으십니다.</p>

<p>이처럼 Python을 설치하는데 있어서도 어떠한 버전을 깔아야할지 헷갈리는 부분들도 있고, 버전에 따라서 호환되는 패키지 버전들도 다르기 때문에 의존성에 굉장히 민감합니다. 프로젝트를 진행하게되면 프로젝트에 따라서 어떤 버전을 사용하고, 어떤 패키지를 사용하고, 또 같은 패키지라도 특정 패키지버전만 호환이 되고 그러한 문제들이 많습니다. 그럴때마다 기존에 Python을 바로 설치해서 사용하시던 분들은 특정 버전으로 Python을 설치해야하기도하며 또는 특정 프로젝트 때문에 상위 버전의 패키지를 사용해야하는데 다른 프로젝트가 패키지를 사용하지 못하는 경우가 발생됩니다. 이를 해결하기 위해서  <code class="highlighter-rouge">pyenv</code>, <code class="highlighter-rouge">virtualenv</code>, <code class="highlighter-rouge">autoenv</code>가 나타나게 됩니다.</p>

<p><br /></p>

<h3 id="pyenv">pyenv</h3>

<p>우선 <code class="highlighter-rouge">pyenv</code>는 시스템 내에 여러 버전의 Python을 설치하고 관리할 수 있는 기능을 제공합니다. 그렇기 때문에 특정 프로젝트는 Python 2.7버전을, 또 다른 프로젝트는 Python 3.6버전을 사용한다면 간단하게 Python 버전을 스위치하듯 바꿔가면서 사용이 가능합니다. 이렇게 되면 Python 버전에 대한 프로젝트 의존성이 해결이 됩니다. <strong>하지만</strong> Python은 기본적으로 각각의 버전마다 패키지를 설치하는 공간을 가지고 있게 되는데 Python을 같은 버전을 사용하더라도 사용하는 패키지의 버전을 다르게 사용의 필요성이 생깁니다. 이를 해결하기 위해 <code class="highlighter-rouge">virtualenv</code>가 나옵니다.</p>

<p><br /></p>

<h3 id="virtualenv">virtualenv</h3>

<p><code class="highlighter-rouge">virtualenv</code>는 프로젝트의 폴더마다 패키지(모듈) 설치하는 공간을 격리해주는 역할을 합니다. 즉, <code class="highlighter-rouge">pyenv</code>로 Python의 버전을 격리하고, <code class="highlighter-rouge">virtualenv</code> 로 격리된 Python버전 내에서 패키지 공간을 격리해주는 역할을 해주게 됩니다. 이를 통해 각각의 프로젝트마다 특정 Python버전과 특정 패키지를 관리할 수 있기 때문에 프로젝트간에 종속성을 없애주는 역할을 합니다. 결과적으로 프로젝트만을 위한 Python 버전과 패키지 버전을 격리된 가상공간에서 사용이 가능하게 됩니다.</p>

<p><br /></p>

<h3 id="autoenv">autoenv</h3>

<p>마지막으로 <code class="highlighter-rouge">autoenv</code>는 일종의 트윅 같은 역할을 하게 되는데, <code class="highlighter-rouge">pyenv</code>와 <code class="highlighter-rouge">virtualenv</code> 환경을 구축하게 되면 특정 프로젝트를 사용할 때마다 <code class="highlighter-rouge">pyenv</code> 로 격리시킨 Python 버전과 <code class="highlighter-rouge">virtualenv</code>로 격리시킨 패키지 구역을 사용하게다라는 커맨드를 쉘에 입력해야하는 번거로움이 있습니다. <em><del>개발자들에게는 엄청나게 구찮은 일이랍니다..</del></em>  그래서 위와같은 특정한 환경을 필요로하는 프로젝트 폴더 내에 격리시키기 위한 커맨드 관련 파일을 만들어 놓고, 개발자가 해당 프로젝트 폴더에 진입했을 때 해당하는 명령어가 자동으로 실행되게 해주는 역할을 해줍니다. 즉, 굳이 프로젝트마다 어떠한 환경으로 실행하라는 것을 외우지도 않고, 따로 칠 필요도 없이 프로젝트에 진입하게 되면 자동으로 격리시키게끔 만들어주는 역할을 합니다.</p>

<p><br /></p>

<hr />

<p><br /></p>

<h2 id="설치-및-사용방법">설치 및 사용방법</h2>

<blockquote>
  <p>필자는 macOS에서 작업을 하기 때문에 macOS에서의 사용방법을 알려드리도록 하겠습니다.</p>
</blockquote>

<h3 id="설치">설치</h3>

<p>각자의 역할을 알았으니 설치하는 방법에 대해서 간단하게 알아보도록 하겠습니다. 기본적으로 macOS를 사용하시는 분들께서는  <a href="https://brew.sh/index_ko.html" title="Homebrew" target="_blank">Homebrew</a>가 깔려 있으실 텐데요, 없으신 경우에는 해당 링크로 가셔서 설치방법대로 설치해주세요~!</p>

<p>설치를 모두 완료하시고 나서는 다음과 같이 설치를 진행합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew update
brew install pyenv
brew install pyenv-virtualenv
brew install autoenv
</code></pre></div></div>

<p>설치가 완료되신 다음에는 프로파일에 몇줄을 추가해주셔야 정상적으로 작동이 가능합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="s1">'eval "$(pyenv init -)"'</span> <span class="o">&gt;&gt;</span> ~/.bash_profile
<span class="nb">echo</span> <span class="s1">'eval "$(pyenv virtualenv-init -)"'</span> <span class="o">&gt;&gt;</span> ~/.bash_profile
<span class="nb">echo</span> <span class="s1">'source $(brew --prefix autoenv)/activate.sh
</span></code></pre></div></div>

<p>1~2번째 줄은 <code class="highlighter-rouge">pyenv</code>와 <code class="highlighter-rouge">virtualenv</code>의 초기 필요한 작업들을 실행해주는 역할을 합니다. 3번째 줄은 프로젝트 폴더에 진입할 때 <code class="highlighter-rouge">.env</code>파일의 스크립트를 자동으로 실행하게 해주는 스크립트입니다.</p>

<p><br /></p>

<h3 id="사용방법">사용방법</h3>

<h4 id="pyenv-1">pyenv</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pyenv versions
</code></pre></div></div>

<p>위와 같은 명령어를 칠 경우 현재 시스템에 <code class="highlighter-rouge">pyenv</code>를 통해 설치 되어있는 Python 버전들을 모두 보여줍니다. 기본적으로 <code class="highlighter-rouge">system</code>이라는 이름으로 되어있으며 이는 시스템에 설치된 Python을 나타냅니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pyenv install <span class="nt">--list</span>
pyenv install 3.6.2
</code></pre></div></div>

<p>1번째 명령어를 통해 <code class="highlighter-rouge">pyenv</code> 를 통해 설치 가능한 Python버전을 모두 보여주며 필요한 버전을 2번째 명령어와 같이 설치하시면 됩니다.</p>

<p>단지 <code class="highlighter-rouge">pyenv </code> 를 통해 Python버전만을 바꾸고 싶다면 <code class="highlighter-rouge">pyenv</code>를 통해 Python을 설치한 후  <code class="highlighter-rouge">pyenv shell 3.6.2</code>와 같이 설치한 Python버전으로 사용하는 Python의 버전을 바꿀 수 있습니다.</p>

<p><br /></p>

<h4 id="virtualenv-1">virtualenv</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pyenv virtualenv 3.6.2 MyProject
virtualenv versions
</code></pre></div></div>

<p>모듈을 격리시키고 싶은 프로젝트의 최상위 폴더에서 1번째 명령어를 입력하면 별명이 ‘MyProject’인 가상 격리공간이 만들어지게 됩니다. 2번째 명령어를 입력함으로써 현재 격리시킨 모든 프로젝트를 보실 수 있습니다.</p>

<p>기본적으로 <code class="highlighter-rouge">autoenv</code>를 사용하지 않을 경우 해당하는 프로젝트로 이동한 후에 <code class="highlighter-rouge">pyenv activate</code>를 입력함으로써 해당하는 가상 격리 공간 상태로 바뀌도록 할 수 있습니다. 위에서 얘기 드렸듯이 매 프로젝트 폴더마다 <code class="highlighter-rouge">pyenv activate</code>를 입력할 경우 많이 귀찮겠죠?</p>

<p><br /></p>

<h4 id="autoenv-1">autoenv</h4>

<p><code class="highlighter-rouge">virtualenv</code>를 통해서 격리시킨 프로젝트 최상위 폴더내에 <code class="highlighter-rouge">.env</code>파일을 생성하고 다음과 같이 입력하고 저장한다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="s2">"Python Pyenv &gt; MyProject 진입"</span>
pyenv shell MyProject
pyenv activate
</code></pre></div></div>

<p>위에서 설명했듯이 해당하는 프로젝트 폴더로 들어올 경우 <code class="highlighter-rouge">.env</code>의 입력된 스크립트를 실행하도록 되어있기 때문에 자동으로 격리공간으로 진입하여 프로젝트마다 따로 명령어를 치실 필요가 없습게 되었습니다.</p>

<p><br /></p>

<hr />

<p><br /></p>

<h1 id="마치며">마치며</h1>

<p>Python 개발 환경을 구축할 때마다 매번 반복하는 구축이라 저 또한 참고하고자 포스트를 쓰게 되었습니다. 이를 통해서 많은 분들이 Python 개발환경을 왜 구축하게 되고, 구축하는데 쉽게 따라하실 수 있으셔서 도움이 많이 돼시면 좋겠습니다. 감사합니다.</p>

	  ]]></description>
	</item>

	<item>
	  <title>macOS 알짜배기 명령어(pbcopy, pbpaste, rsync)</title>
	  <link>https://hashbox.github.io/macOS-%EB%AA%85%EB%A0%B9%EC%96%B4</link>
		
				
		
				
						<author>한지승(Jee Seung, Han)</author>
				
		
	  <pubDate>2017-06-11T09:12:00+00:00</pubDate>
	  <guid>https://hashbox.github.io/macOS-%EB%AA%85%EB%A0%B9%EC%96%B4</guid>
	  <description><![CDATA[
	     <h1 id="개요">개요</h1>

<p>macOS를 사용하면서 터미널에서 제가 많이 사용하는 명령어가 있습니다. 하지만, 다른 개발자분들과 얘기하다보면 생각보다 모르는 분들이 많은 것같아 간단하게 소개시켜 드릴려고 합니다. 제가 소개 시켜드릴려는 명령어는 <code class="highlighter-rouge">pbcopy</code>, <code class="highlighter-rouge">pbpaste</code>, <code class="highlighter-rouge">rsync</code> 입니다. <code class="highlighter-rouge">pbcopy</code>, <code class="highlighter-rouge">pbpaste</code>는 맥에서만 제공되어지는 기능이고, <code class="highlighter-rouge">rsync</code>는 리눅스에서 제공되는 기능으로 맥에도 기본으로 제공하고 있습니다. 지금부터 차근차근 알아보도록 하겠습니다.</p>

<p><br /></p>
<hr />
<p><br /></p>

<h2 id="pbcopy-pbpaste">pbcopy, pbpaste</h2>

<p>우선 명령어만 보셔도 바로 기능이 무엇인지 아실것 같지 않으시나요? 맞습니다. <code class="highlighter-rouge">pbcopy</code>는 클립보드에 복사해 오는 것이고, <code class="highlighter-rouge">pbpaste</code>는 클리보드에 있는 내용을 붙여넣기하는 기능입니다.</p>

<p><br /></p>

<h3 id="pbcopy">pbcopy</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat </span>logs.log | pbcopy
</code></pre></div></div>

<p>위와 같은 명령어는 <code class="highlighter-rouge">logs.log</code>라는 파일의 내용을 모두 클립보드에 복사하라는 의미로 사용하실 수 있습니다. iTerm과 같은 프로그램에서 그냥 드래그하셔서 복사하실 수 있지 않나라고 생각하실 수도 있지만, 저와 같은 경우엔  <code class="highlighter-rouge">vim</code>으로 사용하고 있을 경우 <code class="highlighter-rouge">set nu</code>로 설정하여 줄넘버를 표시하도록 사용하고 있습니다. 이 경우 복사하고 붙여넣었을 때 줄넘버도 같이 복사해서 결국은 다시 코드를 포맷팅 해야하는 귀찮은 작업을 하곤 했습니다. 하지만 <code class="highlighter-rouge">pbcopy</code>와 같은 명령어를 사용할 경우 바로 붙여 넣을 수도 있습니다. 뿐만아니라 터미널에서 작업한 내용을 GUI환경에서 붙여 넣을 때 동안 사용할 수 있기 때문에 알고 있으면 굉장히 편합니다.</p>

<p><br /></p>

<h3 id="pbpaste">pbpaste</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pbpaste | test.txt
</code></pre></div></div>

<p>위와 같은 명령어는 클립보드에 있는 내용으로 <code class="highlighter-rouge">test.txt</code>  파일을 생성하라는 명령어입니다. 즉, 코드를 복사하거나 기본 파일을 만들 때, 클립보드에 있는 내용을 기반으로 <code class="highlighter-rouge">vim</code>과 같은 텍스트 편집기를 열지 않고 바로 생성할 수 있습니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pbpaste | <span class="nb">grep</span> <span class="s2">"바보"</span>
</code></pre></div></div>

<p>또 위와 같은 명령어는 클립보드에 있는 내용에서 <em>바보</em>라는 내용이 있으면 출력해 달라는 구문으로 클립보드 내에서 간단하게 검색도 가능합니다.</p>

<p>이처럼 생각보다 <code class="highlighter-rouge">pbcopy</code>와 <code class="highlighter-rouge">pbpaste</code>는 간단하지만 활용할수록 무궁무진한 응용성과 빠른 편의성을 제공합니다.</p>

<p><br /></p>
<hr />
<p><br /></p>

<h2 id="rsync">rsync</h2>

<p><code class="highlighter-rouge">rsync</code> 는 기본적으로 리눅스에서도 사용되어지는 명령어인데요. 특정 폴더를 다른 폴더내에 똑같이 동기화 시켜주는 역할을 해주는 명령어라 생각하시면 됩니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rsync <span class="nt">-av</span> /path/imoportant/ /home/important/
</code></pre></div></div>

<p>위와 같은 명령어는 <code class="highlighter-rouge">/path/important/</code>의 디렉토리 내에 있는 파일을 <code class="highlighter-rouge">/home/important/</code>에 똑같이 파일을 동기화하라는 명령어입니다. 여기서 문제는 위와 같은 명령어는 생성한 파일들에 대해서는 동기화를 해주지만 <code class="highlighter-rouge">/path/importatnt/</code>에 있는 파일이 삭제될 경우에는 동기화하지 않아 <code class="highlighter-rouge">/home/important/</code>에는 존재합니다. 물론 모든 파일들을 보존하는 차원에서는 위와 같은 명령어를 사용하시면 되지만, 완전히 똑같이 동기화하고 싶은 경우네느 다음과 같은 명령어를 추가해주면 됩니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rsync <span class="nt">-av</span> <span class="nt">--delete</span> /path/important/ /home/important/
</code></pre></div></div>

<p>위와 같이 <code class="highlighter-rouge">--delete</code>를 추가하면 두 디렉토리를 똑같이 동기화할 수 있습니다. 이처럼 같은 로컬 내에서 폴더를 동기화를 하는 방법에 대해서 알아보았지만 원격에 있는 서버에 동기화하고 싶은 경우는 안되는걸까요? 다행히도 원격에도 동기화가 가능합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rsync <span class="nt">-av</span> <span class="nt">--delete</span> /path/important/ root@192.168.0.2:/home/important/
</code></pre></div></div>

<p>위와 같이 <code class="highlighter-rouge">ssh</code> 에 접속하듯이 명명을 해주면 원격에 있는 서버와 동기화도 가능합니다. 단, 원격 서버가 <code class="highlighter-rouge">ssh</code> 포트에 대한 접근이 허용되어 있어야 가능합니다.</p>

<p><br /></p>
<hr />
<p><br /></p>

<h1 id="마무리">마무리</h1>

<p>세 개의 명령어에 대해서 알아보았습니다. 생각보다 간단한 기능이면서 강력한 편의성을 제공해주는 명령어지만 macOS에서 기본으로 제공하는지 모르는 분들이 많습니다. 제 글을 통해서 기본 기능에 대해서 알고 무궁무진하게 활용할 수 있으시면 좋겠습니다.</p>

	  ]]></description>
	</item>

	<item>
	  <title>리눅스 Crontab 사용방법</title>
	  <link>https://hashbox.github.io/Crontab-%EC%82%AC%EC%9A%A9%EB%B0%A9%EB%B2%95</link>
		
				
		
				
						<author>한지승(Jee Seung, Han)</author>
				
		
	  <pubDate>2017-06-08T11:42:00+00:00</pubDate>
	  <guid>https://hashbox.github.io/Crontab-%EC%82%AC%EC%9A%A9%EB%B0%A9%EB%B2%95</guid>
	  <description><![CDATA[
	     <h1 id="개요">개요</h1>
<p>리눅스 환경에서 일정 시간마다 반복된 작업을 스케쥴링을 해야하는 경우가 있습니다. 프로그래밍 내에서 <code class="highlighter-rouge">sleep</code>과 같은 함수를 써서 대기 후 사용하는 무식한 방법도 있지만, 그것 보다 더 좋은 방법은 바로 리눅스 자체의 <code class="highlighter-rouge">crontab</code>을 사용하는 방법이 있습니다. <code class="highlighter-rouge">crontab</code>을 사용하는 방법에 대해서 알아보도록 하겠습니다. <em>현재 저는 CentOS를 기반으로 글을 쓰고 있습니다.</em></p>

<hr />

<h2 id="crontab-기본">Crontab 기본</h2>
<p>기본적으로 리눅스에는 <code class="highlighter-rouge">crontab</code>이 설치 되어 있습니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>crontab <span class="nt">-e</span>
</code></pre></div></div>
<p><code class="highlighter-rouge">crontab -e</code>는 현재 <code class="highlighter-rouge">crontab</code>에 등록할 작업들을 편집하겠다라는 명령어 입니다. 해당 명령어를 입력하면 기본적으로 <code class="highlighter-rouge">vim</code>으로 <code class="highlighter-rouge">crontab</code>에 등록된 파일을 열어 주기 때문에 기존에 있던 스케쥴 내역에 추가로 스케쥴 할 내역을 추가하 실 수 있습니다. 처음 사용하시는 분들은 아무 내용이 없을 것입니다.
<br /><br /></p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>crontab <span class="nt">-l</span>
</code></pre></div></div>
<p><code class="highlighter-rouge">crontab -l</code>은 현재 등록된 스케쥴 내역들을 <code class="highlighter-rouge">cat</code>으로 쉘에 출력 되어집니다. 쉽게 등록된 내용이 무엇이 있는지 확인하기 위해서는 해당 명령어를 입력하면 쉽게 알아내실 수 있습니다.
<br /><br /></p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>crontab <span class="nt">-r</span>
</code></pre></div></div>
<p><code class="highlighter-rouge">crontab -r</code>은 현재 등록된 모든 스케쥴 내역들을 리셋하는 명령어입니다. 기존에 등록된 스케쥴 내역들을 모두 지우고나서 새롭게 쓰고 싶은 경우에 입력하시면 쉽게 리셋하실 수 있습니다.
<br /><br /></p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>crontab <span class="nt">-u</span> &lt;User&gt;
</code></pre></div></div>
<p><code class="highlighter-rouge">crontab</code>은 기본적으로 로그인한 유저의 권한으로 실행 되어집니다. 그렇기 떄문에 해당하는 유저의 권한으로 실행하기 위해서는 해당 유저로 변경해야합니다. 해당 명령어를 통해서 변경하시고 스케쥴을 등록하실 수 있습니다.</p>

<hr />

<h2 id="crontab-포맷-형식">Crontab 포맷 형식</h2>
<p>지금까지 <code class="highlighter-rouge">crontab</code>에 기본 사용법에 대해서 알아 보았는데요. <code class="highlighter-rouge">crontab</code>에 스케쥴링을 등록하기 위해서는 기본적인 형식이 있습니다. 형식에 대해서 알아보도록 하겠습니다.</p>

<p>기본적으로 <code class="highlighter-rouge">crontab</code> 편집창에서는 한줄에 한 스케쥴을 등록하도록 되어있습니다. 즉, 3줄이 씌여져 있다면 3개의 스케쥴링이 명시한 포맷대로 스케쥴링 되고 있는 상태라 생각하시면 됩니다.</p>

<p>그럼 스케쥴 하나에 대한 포맷형식에 대해서 알아보도록 하겠습니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0 */3 * * * /home/slaysd/start.sh
</code></pre></div></div>
<p>대부분의 <code class="highlighter-rouge">crontab</code> 스케쥴들은 위와 같은 형식대로 작성이되어있습니다. 그럼 하나하나씩 확인해보도록 하겠습니다.
<br /><br /></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*       *       *       *       *       &lt;command&gt;
분      시간     일       월      요일
(0-59) (0-23)  (1-31)  (1-12)  (0-7)
</code></pre></div></div>
<p>위와 같은 형태로 입력하시면 해당하는 명령어를 스케쥴대로 등록하실 수 있습니다. 분, 시간, 일, 월, 요일은 <strong>스페이스바</strong>를 기준으로 구분하기 때문에 사이사이는 <strong>스페이스</strong>로 띄워 주셔야합니다.</p>

<hr />

<h2 id="crontab-예시">Crontab 예시</h2>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>30  12  *   *   *   /home/slaysd/start.sh
</code></pre></div></div>
<p>위와 같은 경우에는 매일 12시 30분마다 <code class="highlighter-rouge">/home/slaysd/start.sh</code>을 실행하라라는 의미입니다.
<br /><br /></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>12  *   5   *   *   /home/slaysd/start.sh
</code></pre></div></div>
<p>위와 같은 경우에는 매월 5일에는 매시간 12분이 될떄마다 <code class="highlighter-rouge">/home/slaysd/start.sh</code>를 실행하라는 의미라 생각하시면 됩니다. 쉽게 이해가 되시나요?
<br /><br />
다음은 조금 더 응용하는 방법에 대해서 알아 보도록 하겠습니다.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0   */3 *   *   *   /home/slaysd/start.sh
</code></pre></div></div>
<p>위와 같은 경우에는 0시를 기준으로 매 3시간 정각마다 <code class="highlighter-rouge">/home/slaysd/start.sh</code>를 실행하라는 의미를 가지고 있습니다.
<br /><br /></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>5,15,30 *   *   *   *   /home/slaysd/start.sh
</code></pre></div></div>
<p>위와 같은 경우에는 매시간 5분, 15분, 30분이 될때마다 <code class="highlighter-rouge">/home/slaysd/start.sh</code>를 실행하라는 의미입니다. 특정한 분마다 스케쥴링하고 싶으실때 사용하시면 되겠습니다.
<br /><br /></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>5-30    *   *   *   *   /home/slaysd/start.sh
</code></pre></div></div>
<p>위와 같은 경우에는 5, 6, 7, 8 …, 28, 29, 30분이 될때마다 <code class="highlighter-rouge">/home/slaysd/start.sh</code>를 실행하라는 의미입니다. 특정한 구간에 연속으로 작업을 해야하는 경우이용하시면 되겠습니다.</p>

<hr />

<h1 id="마치며">마치며</h1>
<p>특정 행동을 하는 프로그래밍을 해놓고 정기적으로 스케쥴링이 필요할 경우에 유용한 <code class="highlighter-rouge">crontab</code>에 대해서 알아보았습니다. 생각보다 자주 사용하는 명령어라 아시는 분들도 많을 수도 있지만 생각보다 모르시는 분들이 많아 글로 정리하게 되었습니다. 모두 유용하게 사용하실 수 있으셨으면 좋겠습니다!</p>

	  ]]></description>
	</item>

	<item>
	  <title>Java syncronized, wait, notify, notifyAll에 대하여</title>
	  <link>https://hashbox.github.io/Java-Syncronized-and-method</link>
		
				
		
				
						<author>한지승(Jee Seung, Han)</author>
				
		
	  <pubDate>2017-05-27T13:54:00+00:00</pubDate>
	  <guid>https://hashbox.github.io/Java-Syncronized-and-method</guid>
	  <description><![CDATA[
	     <h1 id="개요">개요</h1>
<p>자바를 사용하면서 쓰레드를 사용한 개발이 필요할 때가 있습니다. 그럴때마다 따라오게 되는 것이 <code class="highlighter-rouge">syncronized</code>와 <code class="highlighter-rouge">wait</code>, <code class="highlighter-rouge">notify</code>, <code class="highlighter-rouge">notifyAll</code>이 있습니다. 어쩔 때 사용한다는 것은 알지만 정확한 작동 원리를 알지 못하고 무분별하게 쓰는 것 같아 자세한 내용을 공부하고 글을 남기게 되었습니다.</p>
<hr />
<h2 id="syncronized">Syncronized</h2>
<p><code class="highlighter-rouge">syncronized</code>는 쓰레드를 사용할 때 동기화가 필요한 부분 즉, 임계영역을 설정할 때 사용합니다. 자바에서 <code class="highlighter-rouge">syncronized</code>를 사용하는 방법은 두가지가 있는데요.</p>
<hr />
<h2 id="함수에-명시하는-방법">함수에 명시하는 방법</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">syncronized</span> <span class="kt">void</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">...</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="n">syncronized</span> <span class="kt">void</span> <span class="nf">set</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br /><br /></p>
<h2 id="객체에-명시하는-방법">객체에 명시하는 방법</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">syncronized</span><span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">...</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이렇게 두가지 방법을 지원합니다.</p>

<p>첫번째 방법인 함수에 명시하는 방법은 해당하는 인스턴스 메소드를 사용할 때만 동기화를 걸어준다고 생각하시면 됩니다. 예를들어 A와 B 쓰레드가 있을 때 A가 <code class="highlighter-rouge">get()</code>을 사용할 때 락을 가지게 되고 임계영역인 <code class="highlighter-rouge">get()</code> 메소드에 진입했을 때 B가 <code class="highlighter-rouge">set()</code>을 사용하려고 해도 락을 가지고 있지 않아 대기하게 됩니다. 어떻게 보면 함수 객체 내에 특정 메소드에만 임계영역을 지정해줌으로써 동기화가 필요하지 않은 메소드에 대해서는 사용이 가능합니다.</p>

<p>두번째 방법인 객체에 명시하는 방법은 해당 객체에 락을 걸어 버리는 것으로 해당 A가 해당 객체를 사용할 때 B는 해당 객체에 진입을 못하는 것에서 차이가 보입니다.</p>

<p>저의 개인적인 생각으로는 첫번째 방법을 사용하는 것이 교착상태에 빠지지 않아 안전하고, 더 빠른 소프트웨어가 아닐까 생각됩니다.</p>
<hr />
<h2 id="wait--notify-notifyall">Wait &amp; Notify, NotifyAll</h2>
<p><code class="highlighter-rouge">syncronized</code>와 함께 따라 오게되는 메소드들이 <code class="highlighter-rouge">wait()</code>, <code class="highlighter-rouge">notify()</code>, <code class="highlighter-rouge">notifyAll()</code>이 있을 텐데요. 3개의 메소드는 <code class="highlighter-rouge">syncronized</code>로 지정된 임계영역에서만 사용이 가능한 함수입니다.</p>

<p><code class="highlighter-rouge">wait()</code>는 락을 가지고 들어온 스레드를 <code class="highlighter-rouge">wait()</code>가 호출된 곳에서 락을 해제하고 잠들게 만듭니다. 일종의 대기실로 들어가게 되는 것인데요. 이럴 경우 A가 락을 가지고 먼저 인스턴스의 <code class="highlighter-rouge">syncronized</code> 영역에 들어갔을 때 B는 인스턴스의 <code class="highlighter-rouge">syncronized</code>에 접근하고자 할 때 락을 얻지 못해 대기하게 됩니다. 이때 A가 <code class="highlighter-rouge">wait()</code>을 만나면 호출된 위치에서 락을 해제하고 잠들게 되고 B는 락을 가짐으로써 <code class="highlighter-rouge">syncronized</code>영역에 들어갈 수 있게 됩니다.</p>

<p><code class="highlighter-rouge">notify()</code>와 <code class="highlighter-rouge">notifyAll()</code>는 잠들어 있는 쓰레드를 깨울 때 사용하게 되는데요. 사실 저도 이 두개의 차이를 조금은 헷갈리기도 했습니다. 그렇기 때문에 서적을 찾아 차이점을 알게되어 글로 남기게 됩니다.</p>

<p><code class="highlighter-rouge">notify()</code>는 <code class="highlighter-rouge">wait()</code>로 잠든 스레드들 중 자바 머신에서 어떤 정책에 의해서 깨우게 되게 됩니다. <del>어떤 정책에 대해서는 한번 알아보고 추가하도록 하겠습니다</del> 그렇기 때문에 개발자는 어떤 쓰레드가 선택될지는 알수가 없습니다.</p>

<p><code class="highlighter-rouge">notifyAll()</code>은 <code class="highlighter-rouge">wait()</code>로 잠든 모든 스레드를 동시에 깨워 냅니다. 하지만 이것은 모든 스레드가 임계영역에 들여올 수 있는 것은 아닙니다. 동시에 일어날 뿐 그 중 한 스레드가 락을 가지게 된다면 다른 스레드는 잠들게 됩니다.</p>

	  ]]></description>
	</item>


</channel>
</rss>
