<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>https://hashbox.github.io/</title>
   
   <link>https://hashbox.github.io/</link>
   <description>빅데이터 분야에 모험가가 되고 싶은 개발자 블로그</description>
   <language>ko-kr</language>
   
   <title>
   <![CDATA[ HASHBOX ]]>
   </title>
   <description>
   <![CDATA[ 빅데이터 분야에 모험가가 되고 싶은 개발자 블로그 ]]>
   </description>
   <link>https://hashbox.github.io/</link>
   <image>
   <url>https://hashbox.github.io/assets/images/favicon.png</url>
   <title>HASHBOX</title>
   <link>https://hashbox.github.io/</link>
   </image>
   <generator>Jekyll 3.6.2</generator>
   <lastBuildDate></lastBuildDate>
   <atom:link href="https://hashbox.github.io/rss.xml" rel="self" type="application/rss+xml"/>
   <ttl>60</ttl>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>CentOS7 + Apache + Tomcat8 연동(mod_jk)</title>
	  <link>https://hashbox.github.io/Apache-Tomcat-%EC%97%B0%EB%8F%99</link>
		
				
		
				
						<author>한지승(Jee Seung, Han)</author>
				
		
	  <pubDate>2017-06-24T10:18:00+00:00</pubDate>
	  <guid>https://hashbox.github.io/Apache-Tomcat-%EC%97%B0%EB%8F%99</guid>
	  <description><![CDATA[
	     <h1 id="개요">개요</h1>

<p>이번에는 CentOS7 환경에서 아파치 <code class="highlighter-rouge">httpd</code>와 <code class="highlighter-rouge">tomcat8</code>을 연동하는 방법에 대해서 알아보도록 하겠습니다. 평소 웹 환경을 구축해야하는 경우가 많은데 매번 할 때마다 까먹고 찾고 하는 시간이 너무 오래 걸리는 것같아 이번에 다시 환경을 만들면서 설치 순서를 기록으로 남겼습니다. 기본적인 환경 구축만을 목표로 하기 때문에 간단하고 추가되는 설정은 없습니다. 환경을 구축하고 난 뒤에 필요하신 옵션을 추가해서 사용하세요~! 지금 부터 알아보도록 하겠습니다.</p>

<p><br /></p>

<hr />

<p><br /></p>

<h2 id="환경을-구축하기-위한-패키지-및-apache-httpd-설치">환경을 구축하기 위한 패키지 및 Apache Httpd 설치</h2>

<p>우선 환경을 구축하기 위해서 필요로 하는 패키지를 한번에 설치하도록 하겠습니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yum install <span class="nt">-y</span> gcc gcc-c++ httpd-devel java-1.8.0-openjdk-devel.x86_64 wget libtool make
</code></pre></div></div>

<p>기본적으로 <code class="highlighter-rouge">libtool</code>, <code class="highlighter-rouge">gcc</code>환경과 <code class="highlighter-rouge">java jdk</code>가 설치 되어 있어야하며, <code class="highlighter-rouge">wget</code>이나 <code class="highlighter-rouge">make</code>는 설치가 안되 있으신 분들은 위해 넣었습니다. 이와 함께 제일 설치하기 쉬운 아파치 설치는 <code class="highlighter-rouge">httpd-devel</code>을 통해서 설치가 가능합니다. 위 명령어를 이용하면 환경을 구축하는데 있어 필요로하는 패키지들과 <code class="highlighter-rouge">apache</code>가 설치가 완료 하셨습니다.</p>

<p><br /></p>

<h2 id="tomcat8-설치">Tomcat8 설치</h2>

<p>저는 <code class="highlighter-rouge">tomcat8</code>을 설치 하게 되었는데요. 이는 http://tomcat.apache.org/download-80.cgi에 들어가시면 최신버전의 톰캣 <code class="highlighter-rouge">tar.gz</code>압축 파일을 받으실 수 있습니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget http://mirror.navercorp.com/apache/tomcat/tomcat-8/v8.5.23/bin/apache-tomcat-8.5.23.tar.gz
<span class="nb">tar </span>zxvf apache-tomcat-8.5.23.tar.gz
mv apache-tomcat-8.5.23.tar.gz /opt/tomcat
</code></pre></div></div>

<p>위와 같은 명령어를 통해서 현재 폴더에 톰캣 압축파일을 받아옵니다.  그 후 <code class="highlighter-rouge">tar</code>명령어를 통해 압축을 풀어주고 난 뒤에 해당 폴더를 그대로 <code class="highlighter-rouge">/opt/tomcat</code>으로 이동을 시켜줍니다.</p>

<p><br /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>groupadd tomcat
<span class="nb">sudo </span>useradd <span class="nt">-M</span> <span class="nt">-s</span> /bin/nologin <span class="nt">-g</span> tomcat <span class="nt">-d</span> /opt/tomcat tomcat
<span class="nb">sudo </span>chown <span class="nt">-R</span> tomcat:tomcat /opt/tomcat
</code></pre></div></div>

<p>그 후 톰캣을 사용하는 유저를 지정해주셔야합니다. <code class="highlighter-rouge">tomcat</code>그룹과 <code class="highlighter-rouge">tomcat</code>유저를 생성하면서 구동파일들을 옮겨놨던 <code class="highlighter-rouge">/opt/tomcat</code>을 지정해주고, 해당 폴더의 소유자를 <code class="highlighter-rouge">tomcat</code>으로 변경해주시면 됩니다.</p>

<p><br /></p>

<p>그 다음에는 톰캣을 서비스에서 등록하고 서버가 부팅될 때 바로 켜지도록 설정을 할 것입니다. 수동으로 켜고 끄시는 것만 하실 경우에는 서비스만 등록하시고 <code class="highlighter-rouge">chkconfig</code> 명령어만 입력 안하셔도 괜찮습니다.</p>

<h3 id="tomcat-서비스-파일-생성">Tomcat 서비스 파일 생성</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vim /etc/systemd/system/tomcat.service
</code></pre></div></div>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span>Unit<span class="p">]</span>
Description<span class="p">=</span>Apache Tomcat Web Application Container
After<span class="p">=</span>syslog<span class="p">.</span>target network<span class="p">.</span>target

<span class="p">[</span>Service<span class="p">]</span>
Type<span class="p">=</span>forking

Environment<span class="p">=</span>JAVA_HOME<span class="p">=</span><span class="sr">/usr/</span>lib<span class="sr">/jvm/</span>java<span class="m">-1</span><span class="p">.</span><span class="m">8</span><span class="p">.</span><span class="m">0</span><span class="p">-</span>openjdk<span class="m">-1</span><span class="p">.</span><span class="m">8</span><span class="p">.</span><span class="m">0</span><span class="p">.</span><span class="m">151-1</span><span class="p">.</span>b12<span class="p">.</span>el7_4<span class="p">.</span>x86_64
Environment<span class="p">=</span>CATALINA_PID<span class="p">=</span><span class="sr">/opt/</span>tomcat<span class="sr">/temp/</span>tomcat<span class="p">.</span>pid
Environment<span class="p">=</span>CATALINA_HOME<span class="p">=</span><span class="sr">/opt/</span>tomcat
Environment<span class="p">=</span>CATALINA_BASE<span class="p">=</span><span class="sr">/opt/</span>tomcat
Environment<span class="p">=</span><span class="s1">'CATALINA_OPTS=-Xms512M -Xmx1024M -server -XX:+UseParallelGC'</span>
Environment<span class="p">=</span><span class="s1">'JAVA_OPTS=-Djava.awt.headless=true -Djava.security.egd=file:/dev/./urandom'</span>

ExecStart<span class="p">=</span><span class="sr">/opt/</span>tomcat<span class="sr">/bin/</span>startup<span class="p">.</span><span class="k">sh</span>
ExecStop<span class="p">=</span><span class="sr">/bin/</span>kill <span class="m">-15</span> $MAINPID

<span class="nb">User</span><span class="p">=</span>tomcat
Group<span class="p">=</span>tomcat
UMask<span class="p">=</span><span class="m">0007</span>
RestartSec<span class="p">=</span><span class="m">10</span>
Restart<span class="p">=</span>always

<span class="p">[</span>Install<span class="p">]</span>
WantedBy<span class="p">=</span>multi<span class="p">-</span>user<span class="p">.</span>target
</code></pre></div></div>

<p><code class="highlighter-rouge">JAVA_HOME</code>과 같은 경우에는 혹시나 다를까 싶어 해당하는 경로를 가져오는 방법까지 첨부합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>which javac
readlink <span class="nt">-f</span> <span class="o">{</span>which javac로 나온 경로를 입력<span class="o">}</span>
</code></pre></div></div>

<p>위와 같은 명령어로 <code class="highlighter-rouge">java</code>가 불려지는 파일 링크의 절대경로를 읽어 올 수 있습니다. 명령어로 얻은 주소에서 <code class="highlighter-rouge">bin</code>경로 전까지의 경로를 <code class="highlighter-rouge">JAVA_HOME</code>에 입력하시면됩니다.</p>

<h3 id="tomcat-서버-부팅시-자동시작">Tomcat 서버 부팅시 자동시작</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>chkconfig tomcat on
</code></pre></div></div>

<p><code class="highlighter-rouge">chkconfig</code>를 통해서 <code class="highlighter-rouge">tomcat</code>서비스가 자동으로 시작되도록 추가해주시면 됩니다.</p>

<p><br /></p>

<h2 id="apache-httpd와-tomcat-연동mod_jk">Apache Httpd와 Tomcat 연동(mod_jk)</h2>

<p><code class="highlighter-rouge">Apache</code>와 <code class="highlighter-rouge">tomcat</code>을 연동하기 위해서는 모듈이 필요한데요. 가장 많이 사용하는 <code class="highlighter-rouge">mod_jk</code>를 이용해서 연동해보도록 하겠습니다. 우선 <code class="highlighter-rouge">mod_jk</code>를 설치파일을 다운 받아야합니다. 파일은 http://tomcat.apache.org/download-connectors.cgi에서 다운로드 받으실 수 있습니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget http://apache.mirror.cdnetworks.com/tomcat/tomcat-connectors/jk/tomcat-connectors-1.2.42-src.tar.gz
<span class="nb">tar </span>zxvf tomcat-connectors-1.2.42-src.tar.gz
<span class="nb">cd </span>tomcat-connectors-1.2.42-src/native/
</code></pre></div></div>

<p>다운로드를 받으신 후 압축을 푸신다음에 해당 폴더에 <code class="highlighter-rouge">native</code>폴더로 들어가셔서 설치를 하셔야 합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./buildconf.sh
./configure <span class="nt">--with-apxs</span><span class="o">=</span>/usr/bin/apxs
make
make install
</code></pre></div></div>

<p>위와 같은 순서대로 설치를 진행해주세요. 혹시나 다른 리눅스 환경에서 설치를 하시는 경우에는 <code class="highlighter-rouge">--with-apxs</code>의 폴더 위치가 다를 수 있습니다. 다른 환경에서 진행 시 <code class="highlighter-rouge">apxs</code>를 찾지 못하는 오류가 있으실 경우에는 리눅스 환경에 맞는 경로를 따로 찾으셔서 적용해주세요. CentOS의 경우에는 위 명령어대로 설치하시면 문제 없이 설치가 완료를 할 수 있습니다.</p>

<p><br /></p>

<h3 id="연동-설정">연동 설정</h3>

<p>설치를 모두 완료 하셨으니 인제 <code class="highlighter-rouge">httpd</code>와 <code class="highlighter-rouge">tomcat</code>간 설정을 해주셔야합니다. 우선 아파치 설정을 잡을 것입니다. CentOS를 사용하시는 경우 아파치 관련 폴더인  <code class="highlighter-rouge">/etc/httpd/</code>에서 폴더 구조가 <code class="highlighter-rouge">conf</code>, <code class="highlighter-rouge">conf.d</code>, <code class="highlighter-rouge">conf.modules.d</code>와 같이 나뉘어져 있습니다. <code class="highlighter-rouge">conf</code>는 아파치의 설정파일만 존재하도록 구성되어있고 추가적인 모듈별 설정 같은 것을 <code class="highlighter-rouge">conf.d</code>에 생성하셔서 사용하시면 자동으로 불러와 적용되어집니다. <code class="highlighter-rouge">conf.modules.d</code>와 같은 경우에는 사용할 모듈을 불러오는 설정만 적용하는 파일들을 관리하는 폴더입니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> /etc/httpd/conf.modules.d/
vim 00-jk.conf
</code></pre></div></div>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code>LoadModule jk_module modules/mod_jk<span class="p">.</span><span class="k">so</span>
</code></pre></div></div>

<p>우선 <code class="highlighter-rouge">conf.module.d</code>폴더에 <code class="highlighter-rouge">mod_jk</code>관련 모듈을 불러오기 위해 <code class="highlighter-rouge">00-jk.conf</code>파일을 생성하고 <code class="highlighter-rouge">LoadModule ~~</code>을 입력하고 저장해주세요. 이는 방금전 설치한 <code class="highlighter-rouge">mod_jk</code>모듈을 불러와 <code class="highlighter-rouge">jk_module</code>이라는 이름으로 명명하는 구문입니다.</p>

<p><br /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> /etc/httpd/conf.d/
vim httpd-jk.conf
</code></pre></div></div>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">&lt;</span>IfModule jk_module<span class="p">&gt;</span>

    # We need <span class="k">a</span> workers <span class="k">file</span> exactly once
    # and <span class="k">in</span> the global server
    JkWorkersFile <span class="k">conf</span><span class="p">.</span><span class="k">d</span>/workers<span class="p">.</span>properties

    JkLogStampFormat <span class="s2">"[%a %b %d %H:%M:%S %Y] "</span>
    # Our JK error log
    # You can <span class="p">(</span>and should<span class="p">)</span> use rotatelogs here
    JkLogFile logs/mod_jk<span class="p">.</span>log

    # Our JK log level <span class="p">(</span>trace<span class="p">,</span><span class="k">debug</span><span class="p">,</span>info<span class="p">,</span>warn<span class="p">,</span>error<span class="p">)</span>
    JkLogLevel info

    # Our JK shared memory <span class="k">file</span>
    JkShmFile logs/mod_jk<span class="p">.</span>shm

    # If you want <span class="k">to</span> <span class="k">put</span> <span class="k">all</span> mounts into an external <span class="k">file</span>
    # that gets reloaded automatically after <span class="k">changes</span>
    # <span class="p">(</span>with <span class="k">a</span> default latency of <span class="m">1</span> minute<span class="p">),</span>
    # you can define the name of the <span class="k">file</span> here<span class="p">.</span>
    JkMountFile <span class="k">conf</span><span class="p">.</span><span class="k">d</span>/uriworkermap<span class="p">.</span>properties

<span class="p">&lt;</span>/IfModule<span class="p">&gt;</span>
</code></pre></div></div>

<p>그 후 불러온 모듈에 대한 설정을 진행해 줍니다. 주의해서 보셔야 할 것은 <code class="highlighter-rouge">JkWorkersFile</code>과 <code class="highlighter-rouge">JkMountFile</code>입니다. 전자는 톰캣 서버들을 각각 설정하는 역할을 해주며, 후자는 특정 패턴을 가지는 파일을 요청했을 때 서비스하고자 하는 톰캣 서버를 지정하는 역할을 합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> /etc/httpd/conf.d/
vim workers.properties
</code></pre></div></div>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code>worker<span class="p">.</span>list<span class="p">=</span>instance1<span class="p">,</span>instance2<span class="p">,</span>instance3

worker<span class="p">.</span>instance1<span class="p">.</span>port<span class="p">=</span><span class="m">8109</span>
worker<span class="p">.</span>instance1<span class="p">.</span>host<span class="p">=</span>localhost
worker<span class="p">.</span>instance1<span class="p">.</span>type<span class="p">=</span>ajp13
worker<span class="p">.</span>instance1<span class="p">.</span>lbfactor<span class="p">=</span><span class="m">1</span>

worker<span class="p">.</span>instance2<span class="p">.</span>port<span class="p">=</span><span class="m">8209</span>
worker<span class="p">.</span>instance2<span class="p">.</span>host<span class="p">=</span>localhost
worker<span class="p">.</span>instance2<span class="p">.</span>type<span class="p">=</span>ajp13
worker<span class="p">.</span>instance2<span class="p">.</span>lbfactor<span class="p">=</span><span class="m">1</span>

worker<span class="p">.</span>instance3<span class="p">.</span>port<span class="p">=</span><span class="m">8309</span>
worker<span class="p">.</span>instance3<span class="p">.</span>host<span class="p">=</span>localhost
worker<span class="p">.</span>instance3<span class="p">.</span>type<span class="p">=</span>ajp13
worker<span class="p">.</span>instance3<span class="p">.</span>lbfactor<span class="p">=</span><span class="m">1</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">workers.properties</code>파일은 위와같이 톰캣서버가 3개일 경우 톰캣서버의 이름들을 설정하고 해당 서버에 대한 설정을 이루도록 되어있습니다. 구축하시려는 환경에 맞게 옵션을 설정해주시면 됩니다.</p>

<p><br /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vim uriworkermap.properties
</code></pre></div></div>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*<span class="p">.</span>jsp<span class="p">=</span>instance1
/*<span class="p">.</span>png<span class="p">=</span>instance2
/*<span class="p">.</span>css<span class="p">=</span>instance3
</code></pre></div></div>

<p><code class="highlighter-rouge">uriworkermap.properties</code>에는 특정 파일에 대해서 어떤 톰캣서버가 서비스할 것인지 맵핑하실 수 있습니다. 해당하는 파일들을 따로 나누어 관리하는 이유는 톰캣이 기본 10분마다 다시불러와 적용하기 때문에 톰캣 설정 변경을 위해 서비스를 재시작하지 않으셔도 적용이 가능하다는 이점이있기 때문입니다.</p>

<p><br /></p>

<h2 id="서비스-재시작">서비스 재시작</h2>

<p>인제 모든 설정을 마무리했습니다. <code class="highlighter-rouge">httpd</code>서비스와 <code class="highlighter-rouge">tomcat</code>서비스를 재시작하셔서 설정된 내용들을 적용하시면 됩니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>service httpd restart
service tomcat restart
</code></pre></div></div>

<p><br /></p>

<h3 id="팁1-연동-설정이-정상적으로-적용이-되는지-확인하는-방법">팁1: 연동 설정이 정상적으로 적용이 되는지 확인하는 방법</h3>

<p>아파치 <code class="highlighter-rouge">httpd</code>에는 정상적으로 설정파일들이 정상적인 Syntax를 가지고 있는지 확인하는 명령어를 내장하고 있습니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apachectl configtest
</code></pre></div></div>

<h3 id="팁2-톰캣-인코딩설정">팁2: 톰캣 인코딩설정</h3>

<p>톰캣에서 한글을 사용할 때 인코딩 문제로 깨지는 문제가 발생하실 수 있기 때문에 인코딩을 설정을 하셔야 합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vim /opt/tomcat/conf/server.xml
</code></pre></div></div>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span>생략<span class="p">)</span>
<span class="p">&lt;</span>Connector port<span class="p">=</span><span class="s2">"8009"</span> protocol<span class="p">=</span><span class="s2">"AJP/1.3"</span> redirectPort<span class="p">=</span><span class="s2">"8443"</span> URIEncoding<span class="p">=</span><span class="s2">"UTF-8"</span> /<span class="p">&gt;</span>
<span class="p">(</span>생략<span class="p">)</span>
</code></pre></div></div>

<p>위와 같이 AJP 커넥터에 <code class="highlighter-rouge">URIEncoding="UTF-8"</code>을 적용하시면 됩니다.</p>

<p><br /></p>

<hr />

<p><br /></p>

<h1 id="마치며">마치며</h1>

<p>매번 환경을 구축할 때마다 괜한 곳에서 헤매는 경우가 많아 제가 많이 사용하는 서버환경에서 구축하는 방법을 정리해보았습니다. 여러번 시도하면서 군더더기 없는 설치를 위해 여러번을 엎고 다시 기록했습니다. 많은 분들께서 도움이 되셨으면 좋겠습니다. 감사합니다!</p>

	  ]]></description>
	</item>

	<item>
	  <title>Java의 Static 바로알기</title>
	  <link>https://hashbox.github.io/Java-Static-%EB%B0%94%EB%A1%9C%EC%95%8C%EA%B8%B0</link>
		
				
		
				
						<author>한지승(Jee Seung, Han)</author>
				
		
	  <pubDate>2017-06-20T20:10:00+00:00</pubDate>
	  <guid>https://hashbox.github.io/Java-Static-%EB%B0%94%EB%A1%9C%EC%95%8C%EA%B8%B0</guid>
	  <description><![CDATA[
	     <h1 id="개요">개요</h1>

<p>Java를 처음 배우게 되는 것 중에 하나는 <code class="highlighter-rouge">static</code>이라는 키워드일것입니다. 또한 Java에 Main 클래스에서 항상 존재하는 <code class="highlighter-rouge">static</code> 키워드는 누구나 익숙하실 겁니다. 하지만 생각보다 <code class="highlighter-rouge">static</code>키워드에 대해서 어쩔때 쓴다 정도는 모두 알고 계시지만 깊이있는 특성을 모르시는 분들이 많습니다. 저 또한 무분별하게 사용했었던 적이 있습니다.  <code class="highlighter-rouge">static</code>키워드의 특성을 자세히 알게 되면 조금 더 활용성 높게 사용하실 수 있습니다. 심지어 취업 면접을 보면서 <code class="highlighter-rouge">static</code>키워드에 대해서 심도 있게 아는지에 대한 면접질문을 많이 받았을 정도로 중요한 부분이라 생각합니다. 지금부터 자세히 알아보도록 하겠습니다.</p>

<p><br /></p>

<hr />

<p><br /></p>

<h2 id="static">static</h2>

<p>처음 Java를 배우시는 분들이 익숙하면서 어쩔때 사용하는지 모르는 키워드는 <code class="highlighter-rouge">static</code> 키워드라 생각합니다. 왜냐하면 Java 프로젝트를 처음 만들고 마주하는 것은 다음과 같은 화면이기 때문이죠.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello World!"</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>저 또한 대학교시절 Java를 처음 배우면서 <code class="highlighter-rouge">main</code>함수에 코딩을 하면서 연습을 했었습니다. 그러다가 자바 메소드에 대해서 알게 되면서 만들어서 사용하려고 하면 빨간줄이 <em>찍</em> 그어지면서 메소드를 호출할 수 없게 되고, 이를 해결하려고 방금 만든 함수에 <code class="highlighter-rouge">static</code>키워드를 붙임으로써 사용이 되는구나하면서 넘어갔던 적이 있습니다. 하지만 이와 같이 작동이 되어야 하는 이유는 생각보다 간단한 이유입니다.</p>

<p><br /></p>

<p><code class="highlighter-rouge">static</code>키워드를 붙인 멤버변수나 메소드와 안 붙인 멤버변수나 메소드와의 <strong>차이점</strong>은 메모리에 적재되는 시기에서부터 시작됩니다. 기본적으로 Java는 객체지향언어로 클래스를 작성하고 해당 클래스를 인스턴스화(객체화)해서 사용하는 형태로 이루어집니다. 여러분들께서 클래스를 작성하고 사용하기 위해서는 <code class="highlighter-rouge">new MyClass()</code>와 같은 형태로 인스턴스를 생성하고 사용을 하시는 이유가 해당 클래스로 인스턴스를 생성하고 생성된 인스턴스로 사용하시기 때문입니다. 그렇기 때문에 인스턴스를 생성하지 않고는 사용하실 경우 에러를 <em>뿜뿜</em>하신다는 것은 모두 알고 계실 것입니다. 이말은 즉, 인스턴스 생성을 할 때 해당 객체가 메모리가 적재 된다는 것을 아실 수 있으십니다.</p>

<p>그렇타면, Java를 배우면서 한번쯤은 모두 써보셨을 만한 Math 클래스는 어떤가요? 실습예제대로 따라하시다보니 잘 모르실 수도 있으시지만 Math 클래스 같은 경우에는 <code class="highlighter-rouge">new Math()</code>와 같은 인스턴스 생성을 하지 않고 바로 <code class="highlighter-rouge">Math.abs()</code>와 같은 형태로 바로 사용하셨을 겁니다. 그렇타면 Math 클래스는 어떻게 사용이 가능한걸까요?</p>

<p><br /></p>

<h3 id="static의-메모리-적재-시기">static의 메모리 적재 시기</h3>

<p>일단 결론부터 말씀드리면 Math 클래스는 모두 <code class="highlighter-rouge">static</code>키워드로 이루어져 있기 때문에 가능합니다. 맞습니다. <code class="highlighter-rouge">static</code>키워드를 붙인 멤버변수나 메소드는 인스턴스를 생성하지도 않아도, JVM이 클래스를 읽어들일 때 이미 자동적으로 메모리에 적재가 일어납니다. 그렇기 때문에 <code class="highlighter-rouge">static</code>키워드를 붙인 멤버변수나 메소드는 인스턴스 생성을 하지 않고도 사용이 가능한 것입니다. 그렇타면 <code class="highlighter-rouge">main(String[] args)</code> 메소드가 <code class="highlighter-rouge">static</code>이 붙는 이유가 이해가 되시나요? 맞습니다, <code class="highlighter-rouge">main(String[] args)</code>는 자바 어플리케이션이 실행될 때 처음으로 실행되는 메소드이기 때문에 메모리에 적재가 되어있어야 실행이 가능하기 때문입니다. 이제 <code class="highlighter-rouge">static</code>을 붙였을 때의 기본적인 원리를 알게되었습니다. 인제 이러한 원리로 인해 어떤 특성을 갖게 되는지 알아 볼까요?</p>

<p><br /></p>

<hr />

<p><br /></p>

<h2 id="static의-특성-및-사용">static의 특성 및 사용</h2>

<h3 id="클래스의-인스턴스-간-공유변수">클래스의 인스턴스 간 공유변수</h3>

<p>클래스를 작성하고 여러 인스턴스를 만들어 사용할 때 모두 똑같은 값을 유지해야하는 경우가 있습니다. 이럴 때 해당 멤버 변수를 <code class="highlighter-rouge">static</code>으로 선언하시면 됩니다. 해당 클래스에서 <code class="highlighter-rouge">static</code>키워드가 붙은 해당 멤버 변수는 인스턴스가 생성되기 전에 메모리를 할당 받기 때문에 모든 인스턴스가 똑같은 멤버변수를 바라보게 됩니다.</p>

<p><br /></p>

<h3 id="static키워드가-붙은-메소드는-static이-것만-사용-가능하다">static키워드가 붙은 메소드는 static이 것만 사용 가능하다!</h3>

<p>그렇습니다. 결론부터 말하면은 <code class="highlighter-rouge">static</code>이 붙은 메소드는 <code class="highlighter-rouge">static</code>이 붙은 멤버변수나 메소드만 사용이 가능합니다. 왜그럴까요? 생각보다 간단한 원리입니다. <code class="highlighter-rouge">static</code>키워드가 붙은 메소드는 인스턴스가 생성되기도 전에 메모리에 적재돼고 사용이 가능해야 합니다. 하지만 해당 메소드 내부에서 <code class="highlighter-rouge">static</code>이 붙지 않은 메소드나 멤버변수를 사용하게 되면? 당연히 에러가 <em>찍</em> 나올 겁니다. 왜냐하면 메모리에 적재되지도 않은 멤버변수나 메소드를 호출하려고 했기 때문입니다. 그렇기 때문에 <code class="highlighter-rouge">static</code>키워드가 붙은 메소드는 사용하는 것들도 <code class="highlighter-rouge">static</code>이 붙어야합니다.</p>

<p><br /></p>

<h3 id="필자의-주관적인-사용-지침">필자의 주관적인 사용 지침</h3>

<p><code class="highlighter-rouge">static</code>키워드에 대해서 알아 보았습니다. 그렇타면 언제 사용하는 것이 좋을까요? 우선 위에서 말씀 드렸듯이 인스턴스간에 공유하는 값이나 공통된 값을 유지해야하는 경우에는 <code class="highlighter-rouge">static</code>사용을 고려하면 되겠습니다.</p>

<p>또한, 작성한 메소드가 멤버변수를 사용하지 않고 파라미터만 사용(메소드 내 변수만)하는 경우 메소드에 <code class="highlighter-rouge">static</code>키워드를 고려해보는 것이 좋지 않을까 싶습니다. <code class="highlighter-rouge">static</code> 키워드를 붙인 메소드는 호출시간이 안 붙인 메소드에 비해 짧기 때문입니다. 기본적으로 <code class="highlighter-rouge">static</code> 키워드를 안 붙인 메소드는 해당 인스턴스의 메소드를 찾는 과정이 일어나기 때문에 비교적 오래 걸리기 때문입니다.</p>

<p>나아가 위와 같은 이유로 유틸리티성이 강한 클래스에 <code class="highlighter-rouge">static</code>을 붙이는 것을 고려해보는 것이 좋습니다. 유틸리티성이 강한 클래스는 인스턴스를 하지 않고도 여러 곳에서 호출이 일어나기 때문에 조금더 호출시간을 줄이고 빠르게 사용하기 위함입니다.</p>

<p><br /></p>

<hr />

<p><br /></p>

<h1 id="마치며">마치며</h1>

<p><code class="highlighter-rouge">static</code>키워드에 대해서 깊이있게 아는 것이 중요하다 생각합니다. 조금이나마 알기 쉽게 또 도움이 될 수 있는 포스트였으면 좋겠습니다. 추가적으로 깊이 있는 내용이 필요하다면 댓글을 달아주시면 저 또한 많은 도움이 돼지 않을까 싶습니다. 감사합니다!</p>

	  ]]></description>
	</item>

	<item>
	  <title>Python 기본 환경 구축하기(pyenv, virtualenv, autoenv)</title>
	  <link>https://hashbox.github.io/Python-%EA%B8%B0%EB%B3%B8%ED%99%98%EA%B2%BD%EA%B5%AD%EC%B6%95</link>
		
				
		
				
						<author>한지승(Jee Seung, Han)</author>
				
		
	  <pubDate>2017-06-15T10:08:00+00:00</pubDate>
	  <guid>https://hashbox.github.io/Python-%EA%B8%B0%EB%B3%B8%ED%99%98%EA%B2%BD%EA%B5%AD%EC%B6%95</guid>
	  <description><![CDATA[
	     <h1 id="개요">개요</h1>

<p>Python을 시작하신지 얼마 안되신 분들은 Python을 사용하기 전에 <code class="highlighter-rouge">pyenv</code>, <code class="highlighter-rouge">virtualenv</code>, <code class="highlighter-rouge">autoenv</code>를 설치하는 이유에 대해서 잘 모르실수도 있습니다. 저또한 처음 시작할 때 굳이 번거롭게 설치할 필요가 있나 했던 적이 있습니다. 지금와서 생각해보면 그런 생각을 할 수 밖에 없는 이유는 대부분 Python 단일 프로젝트로 작업하시거나 또는, 그냥 Python의 패키지들을 전역으로 설치해놓코 사용하시는데 문제가 없으신 분들이라 생각됩니다. 지금부터  <code class="highlighter-rouge">pyenv</code>, <code class="highlighter-rouge">virtualenv</code>, <code class="highlighter-rouge">autoenv</code>가 왜 필요한지에 대해서 설명드리도록 하겠습니다</p>

<p><br /></p>

<hr />

<p><br /></p>

<h2 id="기본적인-이유">기본적인 이유</h2>

<p>일단 Python을 설치하실 때 2.7버전때와 3.6버전으로 두가지로 나뉘어져 있는 것을 알 수 있습니다. 두 버전간에 매우 큰 변화가 있었기 때문에 기존에 존재하던 패키지들과의 호환이 안맞기도하고 없어진 기능들도 있고 이런 저런 이유들로 공존하고 있는 상황입니다. 그렇기 때문에 처음 설치하실 때도 무엇을 깔아야 하는지 모르신 분들도 많으십니다.</p>

<p>이처럼 Python을 설치하는데 있어서도 어떠한 버전을 깔아야할지 헷갈리는 부분들도 있고, 버전에 따라서 호환되는 패키지 버전들도 다르기 때문에 의존성에 굉장히 민감합니다. 프로젝트를 진행하게되면 프로젝트에 따라서 어떤 버전을 사용하고, 어떤 패키지를 사용하고, 또 같은 패키지라도 특정 패키지버전만 호환이 되고 그러한 문제들이 많습니다. 그럴때마다 기존에 Python을 바로 설치해서 사용하시던 분들은 특정 버전으로 Python을 설치해야하기도하며 또는 특정 프로젝트 때문에 상위 버전의 패키지를 사용해야하는데 다른 프로젝트가 패키지를 사용하지 못하는 경우가 발생됩니다. 이를 해결하기 위해서  <code class="highlighter-rouge">pyenv</code>, <code class="highlighter-rouge">virtualenv</code>, <code class="highlighter-rouge">autoenv</code>가 나타나게 됩니다.</p>

<p><br /></p>

<h3 id="pyenv">pyenv</h3>

<p>우선 <code class="highlighter-rouge">pyenv</code>는 시스템 내에 여러 버전의 Python을 설치하고 관리할 수 있는 기능을 제공합니다. 그렇기 때문에 특정 프로젝트는 Python 2.7버전을, 또 다른 프로젝트는 Python 3.6버전을 사용한다면 간단하게 Python 버전을 스위치하듯 바꿔가면서 사용이 가능합니다. 이렇게 되면 Python 버전에 대한 프로젝트 의존성이 해결이 됩니다. <strong>하지만</strong> Python은 기본적으로 각각의 버전마다 패키지를 설치하는 공간을 가지고 있게 되는데 Python을 같은 버전을 사용하더라도 사용하는 패키지의 버전을 다르게 사용의 필요성이 생깁니다. 이를 해결하기 위해 <code class="highlighter-rouge">virtualenv</code>가 나옵니다.</p>

<p><br /></p>

<h3 id="virtualenv">virtualenv</h3>

<p><code class="highlighter-rouge">virtualenv</code>는 프로젝트의 폴더마다 패키지(모듈) 설치하는 공간을 격리해주는 역할을 합니다. 즉, <code class="highlighter-rouge">pyenv</code>로 Python의 버전을 격리하고, <code class="highlighter-rouge">virtualenv</code> 로 격리된 Python버전 내에서 패키지 공간을 격리해주는 역할을 해주게 됩니다. 이를 통해 각각의 프로젝트마다 특정 Python버전과 특정 패키지를 관리할 수 있기 때문에 프로젝트간에 종속성을 없애주는 역할을 합니다. 결과적으로 프로젝트만을 위한 Python 버전과 패키지 버전을 격리된 가상공간에서 사용이 가능하게 됩니다.</p>

<p><br /></p>

<h3 id="autoenv">autoenv</h3>

<p>마지막으로 <code class="highlighter-rouge">autoenv</code>는 일종의 트윅 같은 역할을 하게 되는데, <code class="highlighter-rouge">pyenv</code>와 <code class="highlighter-rouge">virtualenv</code> 환경을 구축하게 되면 특정 프로젝트를 사용할 때마다 <code class="highlighter-rouge">pyenv</code> 로 격리시킨 Python 버전과 <code class="highlighter-rouge">virtualenv</code>로 격리시킨 패키지 구역을 사용하게다라는 커맨드를 쉘에 입력해야하는 번거로움이 있습니다. <em><del>개발자들에게는 엄청나게 구찮은 일이랍니다..</del></em>  그래서 위와같은 특정한 환경을 필요로하는 프로젝트 폴더 내에 격리시키기 위한 커맨드 관련 파일을 만들어 놓고, 개발자가 해당 프로젝트 폴더에 진입했을 때 해당하는 명령어가 자동으로 실행되게 해주는 역할을 해줍니다. 즉, 굳이 프로젝트마다 어떠한 환경으로 실행하라는 것을 외우지도 않고, 따로 칠 필요도 없이 프로젝트에 진입하게 되면 자동으로 격리시키게끔 만들어주는 역할을 합니다.</p>

<p><br /></p>

<hr />

<p><br /></p>

<h2 id="설치-및-사용방법">설치 및 사용방법</h2>

<blockquote>
  <p>필자는 macOS에서 작업을 하기 때문에 macOS에서의 사용방법을 알려드리도록 하겠습니다.</p>
</blockquote>

<h3 id="설치">설치</h3>

<p>각자의 역할을 알았으니 설치하는 방법에 대해서 간단하게 알아보도록 하겠습니다. 기본적으로 macOS를 사용하시는 분들께서는  <a href="https://brew.sh/index_ko.html" title="Homebrew" target="_blank">Homebrew</a>가 깔려 있으실 텐데요, 없으신 경우에는 해당 링크로 가셔서 설치방법대로 설치해주세요~!</p>

<p>설치를 모두 완료하시고 나서는 다음과 같이 설치를 진행합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew update
brew install pyenv
brew install pyenv-virtualenv
brew install autoenv
</code></pre></div></div>

<p>설치가 완료되신 다음에는 프로파일에 몇줄을 추가해주셔야 정상적으로 작동이 가능합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="s1">'eval "$(pyenv init -)"'</span> <span class="o">&gt;&gt;</span> ~/.bash_profile
<span class="nb">echo</span> <span class="s1">'eval "$(pyenv virtualenv-init -)"'</span> <span class="o">&gt;&gt;</span> ~/.bash_profile
<span class="nb">echo</span> <span class="s1">'source $(brew --prefix autoenv)/activate.sh
</span></code></pre></div></div>

<p>1~2번째 줄은 <code class="highlighter-rouge">pyenv</code>와 <code class="highlighter-rouge">virtualenv</code>의 초기 필요한 작업들을 실행해주는 역할을 합니다. 3번째 줄은 프로젝트 폴더에 진입할 때 <code class="highlighter-rouge">.env</code>파일의 스크립트를 자동으로 실행하게 해주는 스크립트입니다.</p>

<p><br /></p>

<h3 id="사용방법">사용방법</h3>

<h4 id="pyenv-1">pyenv</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pyenv versions
</code></pre></div></div>

<p>위와 같은 명령어를 칠 경우 현재 시스템에 <code class="highlighter-rouge">pyenv</code>를 통해 설치 되어있는 Python 버전들을 모두 보여줍니다. 기본적으로 <code class="highlighter-rouge">system</code>이라는 이름으로 되어있으며 이는 시스템에 설치된 Python을 나타냅니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pyenv install <span class="nt">--list</span>
pyenv install 3.6.2
</code></pre></div></div>

<p>1번째 명령어를 통해 <code class="highlighter-rouge">pyenv</code> 를 통해 설치 가능한 Python버전을 모두 보여주며 필요한 버전을 2번째 명령어와 같이 설치하시면 됩니다.</p>

<p>단지 <code class="highlighter-rouge">pyenv </code> 를 통해 Python버전만을 바꾸고 싶다면 <code class="highlighter-rouge">pyenv</code>를 통해 Python을 설치한 후  <code class="highlighter-rouge">pyenv shell 3.6.2</code>와 같이 설치한 Python버전으로 사용하는 Python의 버전을 바꿀 수 있습니다.</p>

<p><br /></p>

<h4 id="virtualenv-1">virtualenv</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pyenv virtualenv 3.6.2 MyProject
virtualenv versions
</code></pre></div></div>

<p>모듈을 격리시키고 싶은 프로젝트의 최상위 폴더에서 1번째 명령어를 입력하면 별명이 ‘MyProject’인 가상 격리공간이 만들어지게 됩니다. 2번째 명령어를 입력함으로써 현재 격리시킨 모든 프로젝트를 보실 수 있습니다.</p>

<p>기본적으로 <code class="highlighter-rouge">autoenv</code>를 사용하지 않을 경우 해당하는 프로젝트로 이동한 후에 <code class="highlighter-rouge">pyenv activate</code>를 입력함으로써 해당하는 가상 격리 공간 상태로 바뀌도록 할 수 있습니다. 위에서 얘기 드렸듯이 매 프로젝트 폴더마다 <code class="highlighter-rouge">pyenv activate</code>를 입력할 경우 많이 귀찮겠죠?</p>

<p><br /></p>

<h4 id="autoenv-1">autoenv</h4>

<p><code class="highlighter-rouge">virtualenv</code>를 통해서 격리시킨 프로젝트 최상위 폴더내에 <code class="highlighter-rouge">.env</code>파일을 생성하고 다음과 같이 입력하고 저장한다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="s2">"Python Pyenv &gt; MyProject 진입"</span>
pyenv shell MyProject
pyenv activate
</code></pre></div></div>

<p>위에서 설명했듯이 해당하는 프로젝트 폴더로 들어올 경우 <code class="highlighter-rouge">.env</code>의 입력된 스크립트를 실행하도록 되어있기 때문에 자동으로 격리공간으로 진입하여 프로젝트마다 따로 명령어를 치실 필요가 없습게 되었습니다.</p>

<p><br /></p>

<hr />

<p><br /></p>

<h1 id="마치며">마치며</h1>

<p>Python 개발 환경을 구축할 때마다 매번 반복하는 구축이라 저 또한 참고하고자 포스트를 쓰게 되었습니다. 이를 통해서 많은 분들이 Python 개발환경을 왜 구축하게 되고, 구축하는데 쉽게 따라하실 수 있으셔서 도움이 많이 돼시면 좋겠습니다. 감사합니다.</p>

	  ]]></description>
	</item>

	<item>
	  <title>macOS 알짜배기 명령어(pbcopy, pbpaste, rsync)</title>
	  <link>https://hashbox.github.io/macOS-%EB%AA%85%EB%A0%B9%EC%96%B4</link>
		
				
		
				
						<author>한지승(Jee Seung, Han)</author>
				
		
	  <pubDate>2017-06-11T09:12:00+00:00</pubDate>
	  <guid>https://hashbox.github.io/macOS-%EB%AA%85%EB%A0%B9%EC%96%B4</guid>
	  <description><![CDATA[
	     <h1 id="개요">개요</h1>

<p>macOS를 사용하면서 터미널에서 제가 많이 사용하는 명령어가 있습니다. 하지만, 다른 개발자분들과 얘기하다보면 생각보다 모르는 분들이 많은 것같아 간단하게 소개시켜 드릴려고 합니다. 제가 소개 시켜드릴려는 명령어는 <code class="highlighter-rouge">pbcopy</code>, <code class="highlighter-rouge">pbpaste</code>, <code class="highlighter-rouge">rsync</code> 입니다. <code class="highlighter-rouge">pbcopy</code>, <code class="highlighter-rouge">pbpaste</code>는 맥에서만 제공되어지는 기능이고, <code class="highlighter-rouge">rsync</code>는 리눅스에서 제공되는 기능으로 맥에도 기본으로 제공하고 있습니다. 지금부터 차근차근 알아보도록 하겠습니다.</p>

<p><br /></p>
<hr />
<p><br /></p>

<h2 id="pbcopy-pbpaste">pbcopy, pbpaste</h2>

<p>우선 명령어만 보셔도 바로 기능이 무엇인지 아실것 같지 않으시나요? 맞습니다. <code class="highlighter-rouge">pbcopy</code>는 클립보드에 복사해 오는 것이고, <code class="highlighter-rouge">pbpaste</code>는 클리보드에 있는 내용을 붙여넣기하는 기능입니다.</p>

<p><br /></p>

<h3 id="pbcopy">pbcopy</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat </span>logs.log | pbcopy
</code></pre></div></div>

<p>위와 같은 명령어는 <code class="highlighter-rouge">logs.log</code>라는 파일의 내용을 모두 클립보드에 복사하라는 의미로 사용하실 수 있습니다. iTerm과 같은 프로그램에서 그냥 드래그하셔서 복사하실 수 있지 않나라고 생각하실 수도 있지만, 저와 같은 경우엔  <code class="highlighter-rouge">vim</code>으로 사용하고 있을 경우 <code class="highlighter-rouge">set nu</code>로 설정하여 줄넘버를 표시하도록 사용하고 있습니다. 이 경우 복사하고 붙여넣었을 때 줄넘버도 같이 복사해서 결국은 다시 코드를 포맷팅 해야하는 귀찮은 작업을 하곤 했습니다. 하지만 <code class="highlighter-rouge">pbcopy</code>와 같은 명령어를 사용할 경우 바로 붙여 넣을 수도 있습니다. 뿐만아니라 터미널에서 작업한 내용을 GUI환경에서 붙여 넣을 때 동안 사용할 수 있기 때문에 알고 있으면 굉장히 편합니다.</p>

<p><br /></p>

<h3 id="pbpaste">pbpaste</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pbpaste | test.txt
</code></pre></div></div>

<p>위와 같은 명령어는 클립보드에 있는 내용으로 <code class="highlighter-rouge">test.txt</code>  파일을 생성하라는 명령어입니다. 즉, 코드를 복사하거나 기본 파일을 만들 때, 클립보드에 있는 내용을 기반으로 <code class="highlighter-rouge">vim</code>과 같은 텍스트 편집기를 열지 않고 바로 생성할 수 있습니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pbpaste | <span class="nb">grep</span> <span class="s2">"바보"</span>
</code></pre></div></div>

<p>또 위와 같은 명령어는 클립보드에 있는 내용에서 <em>바보</em>라는 내용이 있으면 출력해 달라는 구문으로 클립보드 내에서 간단하게 검색도 가능합니다.</p>

<p>이처럼 생각보다 <code class="highlighter-rouge">pbcopy</code>와 <code class="highlighter-rouge">pbpaste</code>는 간단하지만 활용할수록 무궁무진한 응용성과 빠른 편의성을 제공합니다.</p>

<p><br /></p>
<hr />
<p><br /></p>

<h2 id="rsync">rsync</h2>

<p><code class="highlighter-rouge">rsync</code> 는 기본적으로 리눅스에서도 사용되어지는 명령어인데요. 특정 폴더를 다른 폴더내에 똑같이 동기화 시켜주는 역할을 해주는 명령어라 생각하시면 됩니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rsync <span class="nt">-av</span> /path/imoportant/ /home/important/
</code></pre></div></div>

<p>위와 같은 명령어는 <code class="highlighter-rouge">/path/important/</code>의 디렉토리 내에 있는 파일을 <code class="highlighter-rouge">/home/important/</code>에 똑같이 파일을 동기화하라는 명령어입니다. 여기서 문제는 위와 같은 명령어는 생성한 파일들에 대해서는 동기화를 해주지만 <code class="highlighter-rouge">/path/importatnt/</code>에 있는 파일이 삭제될 경우에는 동기화하지 않아 <code class="highlighter-rouge">/home/important/</code>에는 존재합니다. 물론 모든 파일들을 보존하는 차원에서는 위와 같은 명령어를 사용하시면 되지만, 완전히 똑같이 동기화하고 싶은 경우네느 다음과 같은 명령어를 추가해주면 됩니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rsync <span class="nt">-av</span> <span class="nt">--delete</span> /path/important/ /home/important/
</code></pre></div></div>

<p>위와 같이 <code class="highlighter-rouge">--delete</code>를 추가하면 두 디렉토리를 똑같이 동기화할 수 있습니다. 이처럼 같은 로컬 내에서 폴더를 동기화를 하는 방법에 대해서 알아보았지만 원격에 있는 서버에 동기화하고 싶은 경우는 안되는걸까요? 다행히도 원격에도 동기화가 가능합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rsync <span class="nt">-av</span> <span class="nt">--delete</span> /path/important/ root@192.168.0.2:/home/important/
</code></pre></div></div>

<p>위와 같이 <code class="highlighter-rouge">ssh</code> 에 접속하듯이 명명을 해주면 원격에 있는 서버와 동기화도 가능합니다. 단, 원격 서버가 <code class="highlighter-rouge">ssh</code> 포트에 대한 접근이 허용되어 있어야 가능합니다.</p>

<p><br /></p>
<hr />
<p><br /></p>

<h1 id="마무리">마무리</h1>

<p>세 개의 명령어에 대해서 알아보았습니다. 생각보다 간단한 기능이면서 강력한 편의성을 제공해주는 명령어지만 macOS에서 기본으로 제공하는지 모르는 분들이 많습니다. 제 글을 통해서 기본 기능에 대해서 알고 무궁무진하게 활용할 수 있으시면 좋겠습니다.</p>

	  ]]></description>
	</item>

	<item>
	  <title>리눅스 Crontab 사용방법</title>
	  <link>https://hashbox.github.io/Crontab-%EC%82%AC%EC%9A%A9%EB%B0%A9%EB%B2%95</link>
		
				
		
				
						<author>한지승(Jee Seung, Han)</author>
				
		
	  <pubDate>2017-06-08T11:42:00+00:00</pubDate>
	  <guid>https://hashbox.github.io/Crontab-%EC%82%AC%EC%9A%A9%EB%B0%A9%EB%B2%95</guid>
	  <description><![CDATA[
	     <h1 id="개요">개요</h1>
<p>리눅스 환경에서 일정 시간마다 반복된 작업을 스케쥴링을 해야하는 경우가 있습니다. 프로그래밍 내에서 <code class="highlighter-rouge">sleep</code>과 같은 함수를 써서 대기 후 사용하는 무식한 방법도 있지만, 그것 보다 더 좋은 방법은 바로 리눅스 자체의 <code class="highlighter-rouge">crontab</code>을 사용하는 방법이 있습니다. <code class="highlighter-rouge">crontab</code>을 사용하는 방법에 대해서 알아보도록 하겠습니다. <em>현재 저는 CentOS를 기반으로 글을 쓰고 있습니다.</em></p>

<hr />

<h2 id="crontab-기본">Crontab 기본</h2>
<p>기본적으로 리눅스에는 <code class="highlighter-rouge">crontab</code>이 설치 되어 있습니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>crontab <span class="nt">-e</span>
</code></pre></div></div>
<p><code class="highlighter-rouge">crontab -e</code>는 현재 <code class="highlighter-rouge">crontab</code>에 등록할 작업들을 편집하겠다라는 명령어 입니다. 해당 명령어를 입력하면 기본적으로 <code class="highlighter-rouge">vim</code>으로 <code class="highlighter-rouge">crontab</code>에 등록된 파일을 열어 주기 때문에 기존에 있던 스케쥴 내역에 추가로 스케쥴 할 내역을 추가하 실 수 있습니다. 처음 사용하시는 분들은 아무 내용이 없을 것입니다.
<br /><br /></p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>crontab <span class="nt">-l</span>
</code></pre></div></div>
<p><code class="highlighter-rouge">crontab -l</code>은 현재 등록된 스케쥴 내역들을 <code class="highlighter-rouge">cat</code>으로 쉘에 출력 되어집니다. 쉽게 등록된 내용이 무엇이 있는지 확인하기 위해서는 해당 명령어를 입력하면 쉽게 알아내실 수 있습니다.
<br /><br /></p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>crontab <span class="nt">-r</span>
</code></pre></div></div>
<p><code class="highlighter-rouge">crontab -r</code>은 현재 등록된 모든 스케쥴 내역들을 리셋하는 명령어입니다. 기존에 등록된 스케쥴 내역들을 모두 지우고나서 새롭게 쓰고 싶은 경우에 입력하시면 쉽게 리셋하실 수 있습니다.
<br /><br /></p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>crontab <span class="nt">-u</span> &lt;User&gt;
</code></pre></div></div>
<p><code class="highlighter-rouge">crontab</code>은 기본적으로 로그인한 유저의 권한으로 실행 되어집니다. 그렇기 떄문에 해당하는 유저의 권한으로 실행하기 위해서는 해당 유저로 변경해야합니다. 해당 명령어를 통해서 변경하시고 스케쥴을 등록하실 수 있습니다.</p>

<hr />

<h2 id="crontab-포맷-형식">Crontab 포맷 형식</h2>
<p>지금까지 <code class="highlighter-rouge">crontab</code>에 기본 사용법에 대해서 알아 보았는데요. <code class="highlighter-rouge">crontab</code>에 스케쥴링을 등록하기 위해서는 기본적인 형식이 있습니다. 형식에 대해서 알아보도록 하겠습니다.</p>

<p>기본적으로 <code class="highlighter-rouge">crontab</code> 편집창에서는 한줄에 한 스케쥴을 등록하도록 되어있습니다. 즉, 3줄이 씌여져 있다면 3개의 스케쥴링이 명시한 포맷대로 스케쥴링 되고 있는 상태라 생각하시면 됩니다.</p>

<p>그럼 스케쥴 하나에 대한 포맷형식에 대해서 알아보도록 하겠습니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0 */3 * * * /home/slaysd/start.sh
</code></pre></div></div>
<p>대부분의 <code class="highlighter-rouge">crontab</code> 스케쥴들은 위와 같은 형식대로 작성이되어있습니다. 그럼 하나하나씩 확인해보도록 하겠습니다.
<br /><br /></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*       *       *       *       *       &lt;command&gt;
분      시간     일       월      요일
(0-59) (0-23)  (1-31)  (1-12)  (0-7)
</code></pre></div></div>
<p>위와 같은 형태로 입력하시면 해당하는 명령어를 스케쥴대로 등록하실 수 있습니다. 분, 시간, 일, 월, 요일은 <strong>스페이스바</strong>를 기준으로 구분하기 때문에 사이사이는 <strong>스페이스</strong>로 띄워 주셔야합니다.</p>

<hr />

<h2 id="crontab-예시">Crontab 예시</h2>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>30  12  *   *   *   /home/slaysd/start.sh
</code></pre></div></div>
<p>위와 같은 경우에는 매일 12시 30분마다 <code class="highlighter-rouge">/home/slaysd/start.sh</code>을 실행하라라는 의미입니다.
<br /><br /></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>12  *   5   *   *   /home/slaysd/start.sh
</code></pre></div></div>
<p>위와 같은 경우에는 매월 5일에는 매시간 12분이 될떄마다 <code class="highlighter-rouge">/home/slaysd/start.sh</code>를 실행하라는 의미라 생각하시면 됩니다. 쉽게 이해가 되시나요?
<br /><br />
다음은 조금 더 응용하는 방법에 대해서 알아 보도록 하겠습니다.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0   */3 *   *   *   /home/slaysd/start.sh
</code></pre></div></div>
<p>위와 같은 경우에는 0시를 기준으로 매 3시간 정각마다 <code class="highlighter-rouge">/home/slaysd/start.sh</code>를 실행하라는 의미를 가지고 있습니다.
<br /><br /></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>5,15,30 *   *   *   *   /home/slaysd/start.sh
</code></pre></div></div>
<p>위와 같은 경우에는 매시간 5분, 15분, 30분이 될때마다 <code class="highlighter-rouge">/home/slaysd/start.sh</code>를 실행하라는 의미입니다. 특정한 분마다 스케쥴링하고 싶으실때 사용하시면 되겠습니다.
<br /><br /></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>5-30    *   *   *   *   /home/slaysd/start.sh
</code></pre></div></div>
<p>위와 같은 경우에는 5, 6, 7, 8 …, 28, 29, 30분이 될때마다 <code class="highlighter-rouge">/home/slaysd/start.sh</code>를 실행하라는 의미입니다. 특정한 구간에 연속으로 작업을 해야하는 경우이용하시면 되겠습니다.</p>

<hr />

<h1 id="마치며">마치며</h1>
<p>특정 행동을 하는 프로그래밍을 해놓고 정기적으로 스케쥴링이 필요할 경우에 유용한 <code class="highlighter-rouge">crontab</code>에 대해서 알아보았습니다. 생각보다 자주 사용하는 명령어라 아시는 분들도 많을 수도 있지만 생각보다 모르시는 분들이 많아 글로 정리하게 되었습니다. 모두 유용하게 사용하실 수 있으셨으면 좋겠습니다!</p>

	  ]]></description>
	</item>

	<item>
	  <title>Java syncronized, wait, notify, notifyAll에 대하여</title>
	  <link>https://hashbox.github.io/Java-Syncronized-and-method</link>
		
				
		
				
						<author>한지승(Jee Seung, Han)</author>
				
		
	  <pubDate>2017-05-27T13:54:00+00:00</pubDate>
	  <guid>https://hashbox.github.io/Java-Syncronized-and-method</guid>
	  <description><![CDATA[
	     <h1 id="개요">개요</h1>
<p>자바를 사용하면서 쓰레드를 사용한 개발이 필요할 때가 있습니다. 그럴때마다 따라오게 되는 것이 <code class="highlighter-rouge">syncronized</code>와 <code class="highlighter-rouge">wait</code>, <code class="highlighter-rouge">notify</code>, <code class="highlighter-rouge">notifyAll</code>이 있습니다. 어쩔 때 사용한다는 것은 알지만 정확한 작동 원리를 알지 못하고 무분별하게 쓰는 것 같아 자세한 내용을 공부하고 글을 남기게 되었습니다.</p>
<hr />
<h2 id="syncronized">Syncronized</h2>
<p><code class="highlighter-rouge">syncronized</code>는 쓰레드를 사용할 때 동기화가 필요한 부분 즉, 임계영역을 설정할 때 사용합니다. 자바에서 <code class="highlighter-rouge">syncronized</code>를 사용하는 방법은 두가지가 있는데요.</p>
<hr />
<h2 id="함수에-명시하는-방법">함수에 명시하는 방법</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">syncronized</span> <span class="kt">void</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">...</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="n">syncronized</span> <span class="kt">void</span> <span class="nf">set</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br /><br /></p>
<h2 id="객체에-명시하는-방법">객체에 명시하는 방법</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">syncronized</span><span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">...</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이렇게 두가지 방법을 지원합니다.</p>

<p>첫번째 방법인 함수에 명시하는 방법은 해당하는 인스턴스 메소드를 사용할 때만 동기화를 걸어준다고 생각하시면 됩니다. 예를들어 A와 B 쓰레드가 있을 때 A가 <code class="highlighter-rouge">get()</code>을 사용할 때 락을 가지게 되고 임계영역인 <code class="highlighter-rouge">get()</code> 메소드에 진입했을 때 B가 <code class="highlighter-rouge">set()</code>을 사용하려고 해도 락을 가지고 있지 않아 대기하게 됩니다. 어떻게 보면 함수 객체 내에 특정 메소드에만 임계영역을 지정해줌으로써 동기화가 필요하지 않은 메소드에 대해서는 사용이 가능합니다.</p>

<p>두번째 방법인 객체에 명시하는 방법은 해당 객체에 락을 걸어 버리는 것으로 해당 A가 해당 객체를 사용할 때 B는 해당 객체에 진입을 못하는 것에서 차이가 보입니다.</p>

<p>저의 개인적인 생각으로는 첫번째 방법을 사용하는 것이 교착상태에 빠지지 않아 안전하고, 더 빠른 소프트웨어가 아닐까 생각됩니다.</p>
<hr />
<h2 id="wait--notify-notifyall">Wait &amp; Notify, NotifyAll</h2>
<p><code class="highlighter-rouge">syncronized</code>와 함께 따라 오게되는 메소드들이 <code class="highlighter-rouge">wait()</code>, <code class="highlighter-rouge">notify()</code>, <code class="highlighter-rouge">notifyAll()</code>이 있을 텐데요. 3개의 메소드는 <code class="highlighter-rouge">syncronized</code>로 지정된 임계영역에서만 사용이 가능한 함수입니다.</p>

<p><code class="highlighter-rouge">wait()</code>는 락을 가지고 들어온 스레드를 <code class="highlighter-rouge">wait()</code>가 호출된 곳에서 락을 해제하고 잠들게 만듭니다. 일종의 대기실로 들어가게 되는 것인데요. 이럴 경우 A가 락을 가지고 먼저 인스턴스의 <code class="highlighter-rouge">syncronized</code> 영역에 들어갔을 때 B는 인스턴스의 <code class="highlighter-rouge">syncronized</code>에 접근하고자 할 때 락을 얻지 못해 대기하게 됩니다. 이때 A가 <code class="highlighter-rouge">wait()</code>을 만나면 호출된 위치에서 락을 해제하고 잠들게 되고 B는 락을 가짐으로써 <code class="highlighter-rouge">syncronized</code>영역에 들어갈 수 있게 됩니다.</p>

<p><code class="highlighter-rouge">notify()</code>와 <code class="highlighter-rouge">notifyAll()</code>는 잠들어 있는 쓰레드를 깨울 때 사용하게 되는데요. 사실 저도 이 두개의 차이를 조금은 헷갈리기도 했습니다. 그렇기 때문에 서적을 찾아 차이점을 알게되어 글로 남기게 됩니다.</p>

<p><code class="highlighter-rouge">notify()</code>는 <code class="highlighter-rouge">wait()</code>로 잠든 스레드들 중 자바 머신에서 어떤 정책에 의해서 깨우게 되게 됩니다. <del>어떤 정책에 대해서는 한번 알아보고 추가하도록 하겠습니다</del> 그렇기 때문에 개발자는 어떤 쓰레드가 선택될지는 알수가 없습니다.</p>

<p><code class="highlighter-rouge">notifyAll()</code>은 <code class="highlighter-rouge">wait()</code>로 잠든 모든 스레드를 동시에 깨워 냅니다. 하지만 이것은 모든 스레드가 임계영역에 들여올 수 있는 것은 아닙니다. 동시에 일어날 뿐 그 중 한 스레드가 락을 가지게 된다면 다른 스레드는 잠들게 됩니다.</p>

	  ]]></description>
	</item>

	<item>
	  <title>Gitlab to Github 미러링 방법(Git Repo간 미러링)</title>
	  <link>https://hashbox.github.io/Git-%EB%AF%B8%EB%9F%AC%EB%A7%81%EB%B0%A9%EB%B2%95</link>
		
				
		
				
						<author>한지승(Jee Seung, Han)</author>
				
		
	  <pubDate>2017-05-24T12:55:00+00:00</pubDate>
	  <guid>https://hashbox.github.io/Git-%EB%AF%B8%EB%9F%AC%EB%A7%81%EB%B0%A9%EB%B2%95</guid>
	  <description><![CDATA[
	     <p>기존에 사용하고 있던 Repo에서 다른 Repo로 커밋히스토리 그대로 복사가 필요할 때가 있습니다. 저와 같은 경우엔 Private Repo를 무료로 지원해주는 Gitlab을 사용했습니다.
하지만, Github에서 학생들에게는 무료로 Private Repo를 지원해주는 것을 알게 되면서 Github를 사용하기 시작했습니다.</p>

<p>그러면서 기존의 사용하던 Repo를 그대로 가져와야 할 필요가 있었고 역시나 해결방법은 존재했습니다. 대부분의 대규모 프로젝트는 Gerrit을 이용하거나 다른 시스템을 이용할 경우 Github Repo밑에 Mirror라는 링크가 달려 있는걸 볼수 있었습니다. 이는 Git의 <code class="highlighter-rouge">Mirror</code>라는 기능을 이용한 것인데요. 사용법이 정말로 간단합니다.</p>

<hr />

<h1 id="해결방법">해결방법</h1>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git push –mirror https://github.com/jinh574/new-repository.git
</code></pre></div></div>

<p>이와 같이 <code class="highlighter-rouge">-mirror</code> 옵션을 지정해주면 저장소 통채로 옮길 수 있습니다. 나아가 hook을 이용한다면 두개의 Repo를 동시에 운영할 수도 있습니다.</p>

	  ]]></description>
	</item>

	<item>
	  <title>Maven으로 실행가능Jar 빌드 방법</title>
	  <link>https://hashbox.github.io/Maven-JAR%ED%8C%8C%EC%9D%BC%EB%B9%8C%EB%93%9C-%EB%B0%A9%EB%B2%95</link>
		
				
		
				
						<author>한지승(Jee Seung, Han)</author>
				
		
	  <pubDate>2017-05-23T16:01:00+00:00</pubDate>
	  <guid>https://hashbox.github.io/Maven-JAR%ED%8C%8C%EC%9D%BC%EB%B9%8C%EB%93%9C-%EB%B0%A9%EB%B2%95</guid>
	  <description><![CDATA[
	     <p>Maven으로 프로젝트 생성 후 Install 타겟으로 만들어진 Jar파일을 실행할 때 다음과 같은 메세지를 보신적이 많으실 겁니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>JS-Macbook:target js<span class="nv">$ </span>java <span class="nt">-jar</span> eproject.jar
eproject.jar에 기본 Manifest 속성이 없습니다.
</code></pre></div></div>

<p>이는 Maven으로 프로젝트 생성 시 빌드 정보를 생략하고 만들어진 경우 대부분 발생됩니다. 이를 해결하기 위해서는
<code class="highlighter-rouge">pom.xml</code>파일에 빌드 정보를 입력 해 주어야 합니다.
<br /></p>
<hr />
<p><br /></p>
<h1 id="해결방법">해결방법</h1>
<p>다음은 기본적으로 사용하는 최소한의 빌드 정보입니다. <code class="highlighter-rouge">pom.xml</code>파일 내용 중 <code class="highlighter-rouge">&lt;plugins&gt;</code> 태그 안에다가 추가해주시면 됩니다. 만약 <code class="highlighter-rouge">&lt;plugins&gt;</code> 속성이 없다면 <code class="highlighter-rouge">&lt;project&gt;</code>의 <code class="highlighter-rouge">&lt;build&gt;</code> 속성안에다가 생성해주시면 됩니다.</p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;project&gt;</span>
    ...
    <span class="nt">&lt;build&gt;</span>
        <span class="nt">&lt;plugins&gt;</span>
            <span class="nt">&lt;plugin&gt;</span>
                ...
            <span class="nt">&lt;/plugin&gt;</span>
        <span class="nt">&lt;/plugins&gt;</span>
    <span class="nt">&lt;/build&gt;</span>
<span class="nt">&lt;/project&gt;</span>
</code></pre></div></div>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;plugin&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>org.apache.maven.plugins<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>maven-jar-plugin<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;configuration&gt;</span>
        <span class="nt">&lt;archive&gt;</span>
            <span class="nt">&lt;manifest&gt;</span>
                <span class="nt">&lt;addClasspath&gt;</span>true<span class="nt">&lt;/addClasspath&gt;</span>
                <span class="nt">&lt;classpathPrefix&gt;</span>lib/<span class="nt">&lt;/classpathPrefix&gt;</span>
                <span class="nt">&lt;mainClass&gt;</span>com.example<span class="nt">&lt;/mainClass&gt;</span>
            <span class="nt">&lt;/manifest&gt;</span>
        <span class="nt">&lt;/archive&gt;</span>
    <span class="nt">&lt;/configuration&gt;</span>
<span class="nt">&lt;/plugin&gt;</span>
<span class="nt">&lt;plugin&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>org.apache.maven.plugins<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>maven-dependency-plugin<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;executions&gt;</span>
        <span class="nt">&lt;execution&gt;</span>
            <span class="nt">&lt;id&gt;</span>copy<span class="nt">&lt;/id&gt;</span>
            <span class="nt">&lt;phase&gt;</span>install<span class="nt">&lt;/phase&gt;</span>
            <span class="nt">&lt;goals&gt;</span>
                <span class="nt">&lt;goal&gt;</span>copy-dependencies<span class="nt">&lt;/goal&gt;</span>
            <span class="nt">&lt;/goals&gt;</span>
            <span class="nt">&lt;configuration&gt;</span>
                <span class="nt">&lt;outputDirectory&gt;</span>
                    ${project.build.directory}/lib
                <span class="nt">&lt;/outputDirectory&gt;</span>
            <span class="nt">&lt;/configuration&gt;</span>
        <span class="nt">&lt;/execution&gt;</span>
    <span class="nt">&lt;/executions&gt;</span>
<span class="nt">&lt;/plugin&gt;</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">&lt;manifest&gt;</code> 속성 중 <code class="highlighter-rouge">&lt;mainClass&gt;</code>는 프로젝트의 패키지로 맞게 변경해주시면 됩니다.</p>

	  ]]></description>
	</item>

	<item>
	  <title>MySQL 한글 UTF-8 설정[한글 깨짐 현상 해결 방법]</title>
	  <link>https://hashbox.github.io/Mysql-UTF8-%ED%95%9C%EA%B8%80%EC%84%A4%EC%A0%95</link>
		
				
		
				
						<author>한지승(Jee Seung, Han)</author>
				
		
	  <pubDate>2017-05-16T19:18:00+00:00</pubDate>
	  <guid>https://hashbox.github.io/Mysql-UTF8-%ED%95%9C%EA%B8%80%EC%84%A4%EC%A0%95</guid>
	  <description><![CDATA[
	     <p>MySQL을 처음 설치하고 사용하실 때에 한글 데이터가 깨져 나오는걸 경험하신 분이 많으실 거라 생각합니다. 한글 문자열이 <code class="highlighter-rouge">???</code>와 같은 형태로 나오는 이유는 바로 MySQL이 기본적으로 문자셋이 <code class="highlighter-rouge">latin1</code> 문자셋이 기본으로 사용되기 있기 때문인데요, 이를 해결하기 위해서는 문자셋을 <code class="highlighter-rouge">utf-8</code>으로 바꾸어 주셔야 합니다.</p>

<pre><code class="language-mysql">mysql&gt; SELECT * FROM member;
+----+------+
| id | name |
+----+------+
|  1 | ???  |
|  2 | ???  |
+----+------+
2 rows in set (0.01 sec)
</code></pre>
<p><em>한글이 깨져 나오는 테이블 예시</em>
<br /></p>
<hr />
<p><br /></p>
<h1 id="해결방법">해결방법</h1>
<p>이를 해결하기 위해서는 MySQL 설정파일을 수정해주셔야 합니다.</p>

<p><em>MySQL버전이 5.5미만인 경우</em>(경로 : <code class="highlighter-rouge">/etc/my.cnf</code>)</p>
<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[<span class="n">client</span>]
..
<span class="n">default</span>-<span class="n">character</span>-<span class="n">set</span> = <span class="n">utf8</span>

[<span class="n">mysqld</span>]
..
<span class="n">init_connect</span>=<span class="s2">"SET collation_connection = utf8_general_ci"</span>
<span class="n">init_connect</span>=<span class="s2">"SET NAMES utf8"</span>
<span class="n">default</span>-<span class="n">character</span>-<span class="n">set</span> = <span class="n">utf8</span>
<span class="n">character</span>-<span class="n">set</span>-<span class="n">server</span> = <span class="n">utf8</span>
<span class="n">collation</span>-<span class="n">server</span> = <span class="n">utf8_general_ci</span>

[<span class="n">mysql</span>]
..
<span class="n">default</span>-<span class="n">character</span>-<span class="n">set</span> = <span class="n">utf8</span>

[<span class="n">mysqldump</span>]
..
<span class="n">default</span>-<span class="n">character</span>-<span class="n">set</span> = <span class="n">utf8</span>
</code></pre></div></div>
<p><br /><br />
<em>MySQL버전이 5.5이상인 경우</em>(경로 : <code class="highlighter-rouge">/etc/mysql/mysql.conf.d/my.cnf</code>)</p>
<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[<span class="n">mysqld</span>]
..
<span class="n">collation</span>-<span class="n">server</span> = <span class="n">utf8_unicode_ci</span>
<span class="n">character</span>-<span class="n">set</span>-<span class="n">server</span> = <span class="n">utf8</span>
<span class="n">skip</span>-<span class="n">character</span>-<span class="n">set</span>-<span class="n">client</span>-<span class="n">handshake</span>
</code></pre></div></div>

<p>위와 같이 MySQL 설정 파일을 바꿔주신 후 MySQL 데몬을 재시작해주시면 됩니다.</p>

<p>우분투의 경우 <code class="highlighter-rouge">service mysql restart</code>를 입력해주시면 재시작 후 설정값이 적용이 됩니다.</p>

	  ]]></description>
	</item>

	<item>
	  <title>마크다운 이미지 중앙 정렬 방법</title>
	  <link>https://hashbox.github.io/%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%A4%91%EC%95%99%EC%A0%95%EB%A0%AC</link>
		
				
		
				
						<author>한지승(Jee Seung, Han)</author>
				
		
	  <pubDate>2017-05-16T17:18:00+00:00</pubDate>
	  <guid>https://hashbox.github.io/%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%A4%91%EC%95%99%EC%A0%95%EB%A0%AC</guid>
	  <description><![CDATA[
	     <p>마크다운으로 작성시 <code class="highlighter-rouge">![설명](https://hashbox.github.io/images/example.jpg)</code>를 통해 이미지를 등록하게 됩니다.</p>

<p>하지만 해당 마크다운으로 작성 시 이미지가 포스트 넓이보다 작을 경우 이미지가 <em>왼쪽 정렬</em>로만 적용이 되어 이쁘지가 않았습니다.
이럴 경우 적용하믄 적용된 모든 이미지가 중앙 정렬 됨을 확인하였습니다. <code class="highlighter-rouge">jekyll</code>에서 주로 사용되는 <code class="highlighter-rouge">kramdown</code> 환경에서 확인한 방법입니다.
<br /><br /></p>
<h3 id="해결-방법">해결 방법</h3>
<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{: refdef: style="text-align: center;"}
<span class="p">![</span><span class="nv">설명</span><span class="p">](</span><span class="sx">https://hashbox.github.io/images/example.png</span><span class="p">)</span>
{: refdef}
</code></pre></div></div>

	  ]]></description>
	</item>


</channel>
</rss>
